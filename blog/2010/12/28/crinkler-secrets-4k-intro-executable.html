<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="lunet 0.5.3.0">
    <title>Crinkler secrets, 4k intro executable compressor at its best | xoofx</title>
    <link rel="stylesheet" href="/css/site.css">
    <script src="/js/site-defer.js" defer></script>
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@xoofx">
    <meta name="twitter:title" content="Crinkler secrets, 4k intro executable compressor at its best | xoofx">
    <meta name="twitter:description" content="xoofx website">
    <meta name="twitter:image" content="https://xoofx.com/images/twitter-banner.png">
    <meta name="twitter:image:alt" content="Crinkler secrets, 4k intro executable compressor at its best | xoofx">    
    <script src="https://www.googletagmanager.com/gtag/js?id=G-0DVR9ML8KY" async></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-0DVR9ML8KY');</script>
  </head>
  <body>

  <div class="container">
    <div class="row">
      <nav class="navbar navbar-expand-md">
        <div class="container-fluid">
            <a class="xoofx-logo navbar-brand" href="/"></a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
            </button>
            <div id="navbarSupportedContent" class="collapse navbar-collapse justify-content-between">
<ol id='nav-id-home-0' class='navbar-nav nav-level0  w-100'>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/' class='nav-link  '>Home</a></span>  </li>
  <li class='nav-item  active'>
    <span class='nav-item-row'><a href='/blog/' class='nav-link  '>Blog</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/projects/' class='nav-link  '>Projects</a></span>  </li>
  <li class='nav-item  ms-auto'>
    <span class='nav-item-row'><a href='/about/' class='nav-link  '>About</a></span>  </li>
</ol>
            </div>            
        </div>
      </nav>
    </div>
    <div class="row">

<div class="col-sm-9 js-toc-content">
  <p id="lunet-results"></p>
  <article class="page">
    <div class="title">
		  <h1 class="title"><a href="/blog/2010/12/28/crinkler-secrets-4k-intro-executable.html">Crinkler secrets, 4k intro executable compressor at its best</a></h1>
		
    </div>
    <div class="entry-content">
    <div class="blog-post-meta">
      <span class="bi bi-calendar"></span>
      <span class="date"><time datetime="2010-12-28" itemprop="datePublished">December 28, 2010</time></span>
      <i class="bi bi-tags"></i><a href="/blog/tag/x86/">x86</a>, <a href="/blog/tag/demoscene/">demoscene</a>, <a href="/blog/tag/crinkler/">crinkler</a>, <a href="/blog/tag/compression/">compression</a>
  	  <span class="bi bi-edit"></span> <a href="https://github.com/xoofx/xoofx.github.io/edit/master/blog/2010/2010-12-29-crinkler-secrets-4k-intro-executable.html">edit</a>
    </div>




<span style="font-size: x-small;">(Edit 5 Jan 2011: New <a href="/blog/2010/12/29/crinkler-secrets-4k-intro-executable#results">Compression results</a> section and small crinkler x86 decompressor analysis)</span><br /><br />If you are not familiar with 4k intros, you may wonder how things are organized at the executable level to achieve this kind of packing-performance. Probably the most important and essential aspect of 4k-64k intros is the compressor, and surprisingly, 4k intros have been well equipped for the past five years, as <a href="http://crinkler.net/">Crinkler </a>is the best compressor developed so far for this category. It has been created by Blueberry (Loonies) and Mentor (tbc), two of the greatest demomakers around.<br /><br />Last year, I started to learn a bit more about the compression technique used in Crinkler. It started from some pouet's comments that intrigued me, like "crinkler needs several hundred of mega-bytes to compress/decompress a 4k intros" (wow) or "when you want to compress an executable, It can take hours, depending on the compressor parameters"... I observed also <a href="http://www.pouet.net/topic.php?which=6408&amp;page=1&amp;x=29&amp;y=6">bad comrpession result</a>, while trying to convert some part of C++ code to asm code using crinkler... With this silly question, I realized that in order to achieve better compression ratio, you better need a code that is comrpession friendly but is not necessarily smaller. Or in other term, the smaller asm code is not always the best candidate for better compression under crinkler... so right, I needed to understand how crinkler was working in order to code crinkler-friendly code...<br /><br />I just had a basic knowledge about compression, probably the last book I bought about compression was more than 15 years ago to make a presentation about jpeg compression for a physics courses (that was a way to talk about computer related things in a non-computer course!)... I remember that I didn't go further in the book, and stopped just before arithmetic encoding. Too bad, that's exactly one part of crinkler's compression technique, and has been widely used for the past few years (and studied for the past 40 years!), especially in compressors like H.264!<br /><br />So wow, It took me a substantial amount of time to jump again on the compressor's train and to read all those complicated-statistical articles to understand how things are working... but that was worth it! In the same time, I spent a bit of my time to dissect crinkler's decompressor, extract the code decompressor in order to comment it and to compare its implementation with my little-own-test in this field... I had a great time to do this, although, in the end, I found that whatever I could do, under 4k, Crinkler is probably the best compressor ever.<br /><br />You will find here an attempt to explain a little bit more what's behind Crinkler. I'm far from being a compressor expert, so if you are familiar with context-modeling, this post may sounds a bit light, but I'm sure It could be of some interest for people like me, that are discovering things like this and want to understand how they make 4k intros possible!<br /><br /><a name='more'></a><br />
<h2>Crinkler main principles</h2>
<br />If you want a bit more information, you should have a look at the "manual.txt" file in the crinkler's archive. You will find here lots of valuable information ranging from why this project was created to what kind of options you can setup for crinkler. There is also an old but still accurate and worth to look at powerpoint presentation from the author themselves that is available <a href="ftp://ftp.scene.org/pub/parties/2005/assembly05/seminars/crinkler-compression.ppt">here</a>.<br /><br />First of all, you will find that crinkler is not strictly speaking an executable compressor but is rather <b>an integrated linker-compressor</b>. In fact, in the intro dev tool chain, It's used as part of the building process and is used inplace of your traditional linker.... while crinkler has the ability to compress its output. Why crinkler is better suited at this place? Most notably because at the linker level, crinkler has access to portions of your code, your data, and is able to move them around in order to achieve better compression. Though, for this choice, I'm not completely sure, but this could be also implemented as a standard exe compressor, relying on relocation tables in the PE sections of the executable and a good disassembler like <a href="http://www.beaengine.org/">beaengine</a> in order to move the code around and update references... So, crinkler, cr-linker, compressor-linker, is a linker with an integrated compressor.<br /><br />Secondly, crinkler is using a compression method that is far more aggressive and efficient than any old <a href="http://en.wikipedia.org/wiki/Dictionary_coder">dictionary-coder-LZ methods</a> : it's called <b>context modeling coupled with an arithmetic coder</b>. As mentioned in the crinkler's manual, the best place I found to learn about this was <a href="http://mattmahoney.net/dc/">Matt Mahoney resource website</a>. This is definitely the place to start when you want to play with context modeling, as there are lots of sourcecode, previous version of <a href="http://en.wikipedia.org/wiki/PAQ">PAQ </a>program, from which you can learn gradually how to build such a compressor (more particularly in earlier version of the program, when the design was still simple to handle). Building a context-modelling based compressor/decompressor is almost accessible from any developer, but <b>one of the strength of crinkler is its decompressor size </b>: around <b>210-220 bytes</b>, which makes it probably the most efficient and smaller context-modelling decompressor in the world. We will see also that crinkler made one of the simplest choice for a context-modelling compressor, using a semi-static model in order to achieve better compression for 4k of datas, resulting in a less complex decompressor code as well.<br /><br />Lastly, <b>crinkler is optimizing the usage of the exe-PE file </b>(which is the Windows Portable Executable format, the binary format of the a windows executable file, official description is available <a href="http://www.microsoft.com/whdc/system/platform/firmware/pecoff.mspx">here</a>). Mostly by removing the standard import table and dll loading in favor of a custom loader that exploit internal windows structure as well as storing function hashing in the header of the PE files to recover dll functions.<br /><br />
<h2>Compression method</h2>
<br />
<h3>Arithmetic coding</h3>
<br />The whole compression problem in crinkler can be summarized like this: what is the probability of the next bit to compress/decompress to be 1? The better is the probability (meaning by matching the expecting result bit), the better is the compression ratio. Hence, Crinkler needs to be a little bit psychic?!<br /><br />First of all, you probably wonder why probability is important here. This is mainly due to one compression technique called <a href="http://en.wikipedia.org/wiki/Arithmetic_coding">arithmetic coding</a>. I won't go into the detail here and encourage the reader to read about the wikipedia article and related links. The main principle of arithmetic coding is its ability to encode into a single number a set of symbols for which you know their probability to occur. The higher the probability is for a known symbol, the lower the number of bits will be required to encode its compressed counterpart. <br /><br />At the bit level, things are getting even simpler, since the symbols are only 1 or 0. So if you can provide a probability for the next bit (even if this probability is completely wrong), you are able to encode it through an arithmetic coder.<br /><br />A simple binary arithmetic coder interface could look like this:<br />
<pre class="language-cpp"><code>/// Simple ArithmeticCoder interface
class ArithmeticCoder {

   /// Decode a bit for a given probability.
   /// Decode returns the decoded bit 1 or 0
   int Decode(Bitstream inputStream, double probabilityForNextBit);

   /// Encode a bit (nextBit) with a given probability
   void Encode(Bitstream outputStream, int nextBit, double probabilityForNextBit);
}
</code></pre>
<br />And a simple usage of this ArithmeticCoder could look like this:<br />
<pre class="language-cpp"><code>// Initialize variables
Bitstream inputCompressedStream = ...;
Bitstream outputStream = ...;
ArithmeticCoder coder;
Context context = ...;

// Simple decoder implem using an arithmetic coder
for(int i = 0; i &lt; numberOfBitsToDecode; i++) { 
    // Made usage of our psychic alias Context class
    double nextProbability = context.ComputeProbability(); 

    // Decode the next bit from the compressed stream, based on this 
    // probability 
    int nextBit = coder.Decode( inputCompressedStream, nextProbability); 

    // Update the psychic and tell him, how much wrong or right he was! 
    context.UpdateModel( nextBit, nextProbability); 

    // Output the decoded bit 
    outputStream.Write(nextBit); 
}
</code></pre>
<br />So a Binary Arithmetic Coder is able to compress a stream of bits, if you are able to tell him what's the probability for the next bit in the stream. Its usage is fairly simple, although their implementations are often really tricky and sometimes quite obscure (a real arithmetic implementation should face lots of small problems : renormalization, underflow, overflow...etc.). <br /><br />Working at the bit level here wouldn't have been possible 20 years ago, as It requires a tremendous amount of CPU (and memory for the psychic-context) in order to calculate/encode a single bit, but with nowadays computer power, It's less a problem... Lots of implem are working at the byte level for better performance, some of them can work at the bit level while still batching the decoding/encoding results at the byte level. Crinkler doesn't care about this and is working at the bit level, making the arithmetic decoder in less than 20 x86 ASM instructions.<br /><br />The C++ pseudo-code for an arithmetic decoder is like this:<br /><br />
<pre class="language-cpp"><code>int ArithmeticCoder::Decode(Bitstream inputStream, double nextProbability) {
    int output = 0; // the decoded symbol

    // renormalization
    while (range &lt; 0x80000000) {
        range &lt;&lt;= 1; 
        value &lt;&lt;= 1;
        value += inputStream.GetNextBit();
    }

    unsigned int subRange = (range * nextProbability);
    range = range - subRange;
    if (value &gt;= range) { // we have the symbol 1
        value = value - range;
        range = subRange;
        output++;     // output = 1
    }

return output;
}
</code></pre>
<br />This is almost exactly what is used in crinkler, but this done in only 18 asm instructions! The crinkler arithmetic coder is using a 33 bit precision. The decoder only needs to handle up to 0x80000000 limit renormalization while the encoder needs to work on 64 bit to handle the 33 bit precision. This is much more convenient to work at this precision for the decoder, as it is able to easily detect renormalization (0x80000000 is in fact a negative number. The loop could have been formulated like while (range &gt;= 0), and this is how it is done in asm).<br /><br />So the arithmetic coder is the basic component used in crinkler. You will find plenty of arithmetic coder examples on Internet. Even if you don't fully understand the theory behind them, you can use them quite easily. I found for example an interesting project called <a href="http://flavor.sourceforge.net/">flavor</a>, which provides a tool to produce some arithmetic coders code based on a formal description (For example, a <a href="http://flavor.sourceforge.net/samples/bac/tois.htm">32bit precision arithmetic coder </a>description in flavor), pretty handy to understand how things are translated from different coder behaviors.<br /><br />But, ok, the real brain here is not the arithmetic coder... but the psychic-context (the Context class above) which is responsible to provide a probability and to update its model based on the previous expectation. This is where a compressor is making the difference.<br /><br />
<h3>Context modeling - Context mixing</h3>
<br />This is one great point about using an arithmetic coder: they can be decoupled from the component responsible to provide the probability for the next symbol. This component is called a <b>context-modeling</b>. <br /><br />What is the context? It is whatever data can help your context-modeler to evaluate the probability for the next symbol to occur. Thus, the most obvious data for a compressor-decompressor is to use previous decoded data to update its internal probability table.<br /><br />Suppose you have the following sequence of 8 bytes <code>0x7FFFFFFF,0xFFFFFFFF</code> that is already decoded. What will be the next bit? It is certainly to be a 1, and you could bet on it as high as 98% of probability. <br /><br />So this is not a surprise that using history of data is the key point for the context modeler to predict next bit (and well, we have to admit that our computer-psychic is not as good as he claims, as he needs to know the past to predict the future!).<br /><br />Now that we know that to produce a probability for the next bit, we need to use historic data, how crinkler is using them? Crinkler is in fact maintaining a table of probability, up to 8 bytes + the current bits already read before the next bit. In the context-modeling jargon, it's often called the order (before context modeling, there was technique developped like <a href="http://en.wikipedia.org/wiki/Prediction_by_partial_matching">PPM&nbsp; </a>for Partial Predition Matching and <a href="http://en.wikipedia.org/wiki/Dynamic_Markov_compression">DMC</a> for dynamic markov compression). But crinkler is using not only the last x bytes (up to 8), but sparse mode (as it is mentioned in PAQ compressors), a combination of the last 8 bytes + the current bits already read. Crinkler calls this a model: It is stored into a single byte :<br />
<ul>
   <li>The 0x00 model says that It doesn't use any previous bytes other than the current bits being read.</li>
   <li>The 0x80 model says that it is using the previous byte + the current bits being read.</li>
   <li>The 0x81 model says that is is using the previous byte and the -8th byte + the current bits being read.</li>
   <li>The 0xFF model says that all 8 previous bytes are used</li>
</ul>
You probably don't see yet how this is used. We are going to take a simple case here: Use the previous byte to predict the next bit (called the model 0x80). <br /><br />Suppose the sequence of datas :<br />
<pre><code><span style="color: #38761d;">
0xFF, 0x80, 0xFF, 0x85, 0xFF, 0x88, 0xFF</span>, <span style="color: red;">???nextBit???</span>
         (0)         (1)         (2)    (3) | =&gt; decoder position
</code></pre>
<br />
<ul>
   <li>At position 0, we know that 0xFF is followed by bit 1 (0x80 &lt;=&gt; 10000000b). So n0 = 0, n1 = 1 (n0 denotes the number of 0 that follows 0xFF, n1 denotes the number of 1 that usually follows 0xFF)</li>
   <li>At position 1, we know that 0xFF is still followed by bit 1: n0 = 0, n1 = 2</li>
   <li>At position 2, n0 = 0, n1 = 3</li>
   <li>At position 3, we have n0 = 0, n1 = 3, making the probability for one p(1) = (n1 + eps) / ( n0+eps + n1+eps). eps for epsilon, lets take 0.01. We have p(1) = (2+0.01)/(0+0.01 + 2+0.01) = 99,50%</li>
</ul>
<br />So we have the probability of 99,50% at position (3) that the next bit is a 1.<br /><br />The principle here is simple: For each model and an historic value, we associate n0 and n1, the number of bits found for bit 0 (n0) and bit 1 (n1). Updating those n0/n1 counters needs to be done carefully : a naive approach would be to increment according values when a particular training bit is found... but there is more chance that recent values are more relevant than olders.... Matt Mahoney explained this in <a href="http://mattmahoney.net/dc/paq1.pdf"><i>The PAQ1 Data Compression Program</i></a>, 2002. (Describes PAQ1), and describes how to efficiently update those counters for a non-stationary source of data :<br />
<ul>
   <li>If the training bit is y (0 or 1) then increment ny (n0 or n1).</li>
   <li>If n(1-y) &gt; 2, then set n(1-y) = n(1-y) / 2 + 1 (rounding down if odd). </li>
</ul>
<br />Suppose for example that n0 = 3 and n1 = 4 and we have a new bit 1. Then n0 will be = n0/2 + 1 = 3/2+1=2 and n1 = n1 + 1 = 5<br /><br />Now, we know how to produce a single probability for a single model... but working with a single model (for exemple, only the previous byte) wouldn't be enough to evaluate correctly the next bit. Instead, we need a way to combine different models (different selection of historic data). This is called <b>context-mixing</b>, and this is the real power of context modeling: whatever is your method to collect and calculate a probability, you can, at some point, mix severals estimator to calculate a single probability.<br /><br />There are several ways to mix those probabilities. In the pure context-modeling jargon,&nbsp; the model is the way you mix probabilities and for each model, you have a weight :<br />
<ul>
   <li><b>static</b>: you determine the weights whatever the data are.</li>
   <li><b>semi-static</b>: you perform a 1st pass over the data to compress to determine the weights for each model, and them a 2nd pass with the best weights</li>
   <li> <b>adaptive</b>: weights are updated dynamically as new bits are discovered.</li>
</ul>
<br /><b>Crinkler is using a semi-static context-mixing</b> but is somewhat also "semi-adaptive", because It is using different weights for the code of your exe, and the data of your exe, as they have a different binary layout.<br /><br />So how this is mixed-up? Crinkler needs to determine the best context-models (the combination of historic data) that It will use, assign for each of those context a weight. The weight is then used to calculate the final probability.<br /><br /><br />For each selected historic model (i) with an associated model weight wi, and ni0/ni1 bit counters, the final probability p(1) is calculated like this :<br /><br />
<div style="text-align: center;">
   <pre>p(1) = Sum(&nbsp; wi * ni1 / (ni0 + ni1))&nbsp; / Sum ( wi )</pre>
</div>
<br />This is exactly what is done in the code above for <code>context.ComputeProbability();</code>, and this is exactly what crinkler is doing.<br /><br />In the end, crinkler is selecting a list of models for each type of section in your exe: a set of models for the code section, a set of models for the data section.<br /><br />How many models crinkler is selecting? It depends on your data. For example, for <a href="/blog/2010/08/25/making-of-ergon-4k-pc-intro">ergon </a>intro,crinklers is selecting the following models:<br /><br />
<pre><code>For the code section:
           0    1    2    3    4    5    6    7    8    9   10   11   12   13 
Model  {0x00,0x20,0x60,0x40,0x80,0x90,0x58,0x4a,0xc0,0xa8,0xa2,0xc5,0x9e,0xed,}
Weight {   0,   0,   0,   1,   2,   2,   2,   2,   3,   3,   3,   4,   6,   6,}

For the data section:
           0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19 
Model  {0x40,0x60,0x44,0x22,0x08,0x84,0x07,0x00,0xa0,0x80,0x98,0x54,0xc0,0xe0,0x91,0xba,0xf0,0xad,0xc3,0xcd,}
Weight {   0,   0,   0,   0,   0,   0,   0,   1,   1,   2,   2,   2,   3,   3,   3,   4,   4,   4,   4,   5,}
</code></pre>
(note that in crinkler, the final weight used to multiply n1/n0+n1 is by 2^w, and not wi itself).<br /><br />Wow, does it means that crinkler needs to store those datas in your exe. (14 bytes + 20 bytes) * 2 = 68 bytes? Well, crinkler authors are smarter than this! In fact the models are stored, but weights are only store in a single int (32 bits for each section). Yep, a single int to stored those weights? Indeed: if you look at those weights, they are increasing, sometimes they are equal... So they found a clever way to store a compact representation of those weights in a 32 bit form. Starting with a weight of 1, the 32bit weight is shifted by one bit to the left : If this is 0, than the currentWeight doesn't change, if bit is 1, than currentWeight is incremented by 1 : (in this pseudo-code, shift is done to the right)<br /><br />
<pre class="language-cpp"><code>int currentWeight = 1;
int compactWeight = ....;
foreach (model in models) {
&nbsp; if ( compactWeight &amp; 1 )
&nbsp;&nbsp;&nbsp; currentWeigh++;
&nbsp; compactWeight =&nbsp; compactWeight &gt;&gt; 1;

//&nbsp; ... used currentWeight for current model
}
</code></pre>
<br />This way, crinkler is able to store a compact form of pairs (model/weight) for each type of data in your executable (code or pure data).<br /><br />
<h3>Model selection</h3>
<br />Model selection is one of the key process of crinkler. For a particular set of datas, what is the best selection of models? You start with 256 models (all the combinations of the 8 previous bytes) and you need to determine the best selection of models. You have to take into account that each time you are using a model, you need to use 1 byte in your final executable to store this model. Model selection is part of crinkler compressor but is not part of crinkler decompressor. The decompressor just need to know the list of the final models used to compress the data, but doesn't care about intermediate results. On the other hand, the compressor needs to test every combination of model, and find an appropriate weight for each model.<br /><br />I have tested several methods in my test code and try to recover the method used in crinkler, without achieving comparable compression ratio... I tried some brute force algo without any success... The selection algorithm is probably a bit clever than the one I have tested, and would probably require to layout mathematics/statistics formulas/combination to select an accurate method.<br /><br />Finally, blueberry has given their method (thanks!) <br /><br />"<i>To answer your question about the model selection process, it is  actually not very clever. We step through the models in bit-mirrored  numerical order (i.e. 00, 80, 40, C0, 20 etc.) and for each step do the  following:<br /><br />- Check if compression improves by adding the model to  the current set of models (taking into account the one extra byte to  store the model).<br /><br />- If so, add the model, and then step through every model in the current set and remove it if compression improves by doing so.<br /><br />The  difference between FAST and SLOW compression is that SLOW optimizes the  model weights for every comparison between model sets, whereas FAST  uses a heuristic for the model weights (number of bits set in the model  mask). </i>"<br /><br /><br />On the other hand, I tried a fully adaptive context modelling approach, using dynamic weight calculation explained by Matt Mahoney with neural networks and stretch/squash functions (look at PAQ on wikipedia). It was really promising, as I was able to achieve sometimes better compression ratio than crinkler... but at the cost of a decompressor 100 bytes heavier... and even I was able to save 30 to 60 bytes for the compressed data, I was still off by 40-70 bytes... so under 4k, this approach was definitely not as efficient as a semi-static approach chosen by crinkler.<br /><br />
<h3>Storing probabilities</h3>
<br />If you have correctly followed the previous model selection, crinkler is now working with a set of models (selection of history data), for each bit that is found, each model probabilities must be updated...<br /><br />But think about it: for example, if to predict the following bit, we are using the probabilities for the 8 previous bytes, it means that for every combination of 8 bytes already found in the decoded data, we would have a pair of n0/n1 counters?<br /><br />That would mean that we could have the folowing probabilities to update for the context 0xFF (8 previous bytes):<br />- "00 00 00 00 c0 00 00 <span style="color: #b45f06;">50 </span><span style="color: #38761d;">00</span>" =&gt; some n0/n1<br />- "00 00 70 00 00 00 00 <span style="color: #b45f06;">F2 </span><span style="color: #38761d;">01</span>" =&gt; another n0/n1<br />- "00 00 00 40 00 00 00 <span style="color: #b45f06;">30 </span><span style="color: #38761d;">02</span>" =&gt; another n0/n1 <br />...etc.<br /><br />and if we have other models like 0x80 (previous byte), or 0xC0 (the last 2 previous bytes), we would have also different counters for them:<br />
<table>
   <tbody>
      <tr>
         <td>
            <br />
            <div style="text-align: left;">// For model 0x80</div>
            <div style="text-align: left;">- "<span style="color: #38761d;">00</span>" =&gt; some n0/n1</div>
            <div style="text-align: left;">- "<span style="color: #38761d;">01</span>" =&gt; another n0/n1</div>
            <div style="text-align: left;">- "<span style="color: #38761d;">02</span>" =&gt; yet another n0/n1 </div>
            <div style="text-align: left;">...</div>
         </td>
         <td>
            <br />
            <div style="text-align: left;">// For model 0xC0</div>
            <div style="text-align: left;">- "<span style="color: #b45f06;">50 </span><span style="color: #38761d;">00</span>" =&gt; some bis n0/n1</div>
            <div style="text-align: left;">- "<span style="color: #b45f06;">F2 </span><span style="color: #38761d;">01</span>" =&gt; another bis n0/n1</div>
            <div style="text-align: left;">- "<span style="color: #b45f06;">30 </span><span style="color: #38761d;">02</span>" =&gt; yet another bis n0/n1 </div>
            <div style="text-align: left;">...</div>
         </td>
      </tr>
   </tbody>
</table>
<br />From the previous model context, I have slightly over simplified the  fact that not only the previous bytes is used, but also the current bits  being read. In fact, when we are using for example the model 0x80 (using the previous byte), the context of the historic data is composed not only by the previous byte, but also by the bits being read on the current octet. This implies obviously that for every bit read, there is a different context. Suppose we have the sequence 0x75, 0x86 (in binary 10000110b), the position of the encoded bits is just after the 0x75 value and that we are using the previous byte + the bits currently read:<br /><br />First, we start on a byte boundary<br />- 0x75 with 0 bit (we start with 0) is followed by bit 1 (the 8 of 0x85). The context is 0x75 + 0 bit read<br />- We read one more bit, we have a new context :&nbsp; 0x75 + bit 1. This context is followed by a 0<br />- We read one more bit, we have a new context :&nbsp; 0x75 + bit 10. This context is followed by a 0.<br />...<br />- We read one more bit, we have a new context :&nbsp; 0x75 + bit 1000011, that is followed by a 0 (and we are ending on a byte boundary).<br /><br />Reading 0x75 followed by 0x86, with a model using only the previous byte, we finally have 8 context with their own n0/n1 to store in the probability table.<br /><br />As you can see, It is obvious that It's difficult to store all context found (.i.e for each single bit decoded, there is a different context of historic bytes) and their respective exact probability counters, without exploding the RAM. Moreover if you think about the number of models that are used by crinkler: 14 types of different historic previous bytes selection for ergon's code!<br /><br />This kind of problem is often handled using a hashtable while handling collisions. This is what is done in some of the PAQ compressors. <b>Crinkler is also using an hashtable to store counter probabilities</b>, with the association context_history_of_bytes = &gt; (n0/n1), but It is not handling collision in order to keep minimal the size of the decompressor. As usual, the hash function used by crinkler is really tiny while still giving really good results.<br /><br />So instead of having the association between&nbsp; context_history_of_bytes =&gt; n0/n1, we are using a hashing function, hash(context_history_of_bytes) =&gt; n0/n1. Then, the dictionary that is storing all those associations needs to be correctly dimensioned, large enough, to store as much as possible associations found while decoding/encoding the data.<br /><br />Like in PAQ compressors, <b>crinkler is using one byte for each counter</b>, meaning that n0 and n1 together are taking 16 bit, 2 bytes. So if you instruct crinkler to use a hashtable of 100Mo, It will be possible to store 50 millions of different keys, meaning different historic context of bytes and their respective probability counters. There is a little remark about crinkler and the byte counter: in PAQ compressors, limits are handled, meaning that if a counter is going above 255, It will stuck to 255... but crinkler made the choice to not test the limits in order to keep the code smaller (although, that would take less than 6 bytes to test the limit). What is the impact of this choice? Well, if you know crinkler, you are aware that crinkler doesn't handle large section of "zeros" or whatever empty initialized data. This is just because the probabilities are looping from 255 to 0, meaning that you jump from a 100% probability (probably accurate) to almost a 0% probability (probably wrong)&nbsp; every 256 bytes. Is this really hurting the compression? Well, It would hurt a lot if crinkler was used for larger executable, but in a 4k, It's not hurting so much (although, It could hurt if you really have large portions of initialized data). Also, not all the context are reseted at the same time (a 8 byte context will not probably reset as often as a 1 byte context), so it means that final probability calculation is still accurate... while there is a probability that is reseted, other models with their own probabilities are still counting there... so this is not a huge issue.<br /><br />What happens also if the hash for a different context is giving the same value? Well, the model is then updating the wrong probability counters. If the hashtable is too small the probability counters may really be too much disturbed and they would provide a less accurate final probability. But if the hashtable is large enough, collisions are less likely to happen.<br /><br />Thus, it is quite common to use a hashtable as large as 256 to 512Mo if you want, although 256Mo is often enough, but the larger is your hashtable, the less are collisions, the more accurate is your probability. Recall from the beginning of this post, and you should understand now why "crinkler can take several hundreds of megabytes to decompress"... simply because of this hashtable that store all the probabilities for the next bit for all models combination used.<br /><br />If you are familiar with crinkler, you already know the option to find a best possible hashsize for an initial hashtable size and a number of tries (hashtries option). This part is responsible to test different size of hashtable (like starting from 100Mo, and reducing the size by 2 bytes 30 times, and test the final compression) and test final compression result. This is a way to empirically reduce collision effects by selecting the hashsize that is giving the better compression ratio (meaning less collisions in the hash). Although this option is only able to help you save a couple of bytes, no more.<br /><br /><br />
<h3>Data reordering and type of data</h3>
<br />Reordering or organizing differently the data to have a better compression is one of the common technique in compression methods. Sometimes for example, Its better to store deltas of values than to store values themselves...etc.<br /><br /><b>Crinkler is using this principle to perform data reordering</b>. At the linker level, crinkler has access to portion of datas and code, and is able to move those portions around in order to achieve a better compression ratio. This is really easy to understand : suppose that you have a series initialized zero values in your data section. If those values are interleaved with non zero values, the counter probabilities will switch from "there are plenty of zero there" to "ooops, there are some other datas"... and the final probability will balance between 90% to 20%. Grouping data that are similar is a way to improve the overall probability correctness.<br /><br />This part is the most time consuming, as It needs to move and arrange all portions of your executable around, and test which arrangement is giving the best compression result. But It's paying to use this option, as you may be able to save 100 bytes in the end just with this option.<br /><br />One thing that is also related to data reordering is the way <b>crinkler is handling separately the binary code and the data of your executable</b>. Why?, because their binary representation is different, leading to a completely different set of probabilities. If you look at the selected models for ergon, you will find that code and data models are quite different. Crinkler is using this to achieve better performance here. In fact, crinkler is compressing completely separately the code and the datas. Code has its own models and weights, Data another set of models and weights. What does it means internally? Crinkler is using a set of model and weights to decode the code section of your exectuable. Once finished, It will erase the probability counters stored in the hashtable-dictionary, and go to the data section, with new models and weights. Reseting all counters to 0 in the middle of decompressing is improving compression by a factor of 2-4%, which is quite impressive and valuable for a 4k (around 100 to 150 bytes).<br /><br />I found that even with an adaptive model (with a neural networks dynamically updating the weights), It is still worth to reset the probabilities between code and data decompression. In fact, reseting the probabilities is an empirical way to instruct the context modeling that datas are so different that It's better to start from scratch with new probability counters. If you think about it, an improved demo compressor (for larger exectuable, for example under 64k) could be clever to detect those portions of datas that are enough different that It would be better to reset the dictionary than to keep it as it is.<br /><br />There is just one last thing about weights handling in crinkler. When decoding/encoding, It seems that crinkler is artificially increasing the weights for the first discovered bit. This little trick is improving compression ratio by about 1 to 2% which is not bad. Having higher weights at the beginning enable to have a better response of the compressor/decompressor, even If it doesn't still have enough data to compute a correct probability. Increasing the weights is helping the compression ratio at cold start.<br /><br />Crinkler is also able to transform the x86 code for the executable part to improve compression ratio. This technique is widely used and consist of replacing relative jump (conditionnal, function calls...etc.) to absolute jump, leading to a better compression ratio.<br /><br />
<h2>Custom DLL LoadLibrary and PE file optimization</h2>
<br />In order to strip down the size of an executable, It's necessary to exploit as much as possible the organization of a PE file.<br /><br />First thing that crinkler is using is that lots of part in a PE files are not used at all. If you want to know how a windows executable PE files can be reduced, I suggest you read <a href="http://www.phreedom.org/solar/code/tinype/">Tiny PE</a> article, which is a good way to understand what is actually used by a PE loader. Unlike the Tiny PE sample, where the author is moving the PE header to the dos header, crinkler made the choice to use this unused place to store hash values that are used to reference DLL functions used.<br /><br />This trick is called import by hashing and is quite common in intro's compressor. Probably what make crinkler a little bit more advanced is that to perform the "GetProcAddress" (which is responsible to get the pointer to a function from a function name), <b>crinkler is navigating inside internal windows process structure in order to directly get the address of the functions from the in-memory import table. </b>Indeed, you won't find any import section table in a crinklerized executable. Everything is re-discovered through internal windows structures. Those structures are not officially documented but you can find some valuable information around, most notably <a href="http://www.alex-ionescu.com/part1.pdf">here</a>.<br /><br />If you look at crinkler's code stored in the crinkler import section, which is the code injected just before the intros start, in order to load all dll functions, you will find those cryptics calls like this:<br />
<pre><code>//
    (0) MOV         EAX, FS:[BX+0x30]
    (1) MOV         EAX, [EAX+0xC]
    (2) MOV         EAX, [EAX+0xC]
    (3) MOV         EAX, [EAX]
    (4) MOV         EAX, [EAX]
    (5) MOV         EBP, [EAX+0x18]
</code></pre>
<br /><br />This is done by going through internal structures: <br />
<ul>
   <li><b>(0)</b> first crinklers gets a pointer to the "PROCESS ENVIRONMENT BLOCK (PEB)" with the instruction&nbsp; <code>MOV EAX, FS:[BX+0x30]</code>. EAX is now pointing to the PEB&nbsp;</li>
</ul>
<pre><span style="color: blue;">Public Type</span> <span style="background-color: #990000;"><span style="background-color: white; color: #990000;">PEB</span></span>&nbsp;</pre>
<pre>InheritedAddressSpace As <span style="color: #990000;">Byte</span><br />    ReadImageFileExecOptions As <span style="color: #990000;">Byte</span><br />    BeingDebugged As <span style="color: #990000;">Byte</span><br />    Spare As <span style="color: #990000;">Byte</span><br />    Mutant As <span style="color: #990000;">Long</span><br />    SectionBaseAddress As <span style="color: #990000;">Long</span><br />    ProcessModuleInfo As <span style="color: #990000;">Long </span>‘ <b><span style="color: #38761d;">// &lt;---- PEB_LDR_DATA</span></b><br />    ProcessParameters As <span style="color: #990000;">Long </span>‘ <span style="color: #38761d;">// RTL_USER_PROCESS_PARAMETERS</span><br />    SubSystemData As <span style="color: #990000;">Long</span><br />    ProcessHeap As <span style="color: #990000;">Long</span><br />    ... struct continue</pre>
<br />
<ul>
   <li><b>(1)</b> Then it gets a pointer to the "ProcessModuleInfo/PEB_LDR_DATA" <code>MOV EAX, [EAX+0xC]</code></li>
</ul>
<pre><span style="color: #0b5394;"><span style="color: blue;">Public Type</span> </span><span style="color: #990000;">_PEB_LDR_DATA</span><br />    Length As <span style="color: #990000;">Integer</span><br />    Initialized As <span style="color: #990000;">Long</span><br />    SsHandle As <span style="color: #990000;">Long</span><br />    InLoadOrderModuleList As <span style="color: #990000;">LIST_ENTRY</span>  <b><span style="color: #38761d;">// &lt;---- LIST_ENTRY InLoadOrderModuleList</span></b><br />    InMemoryOrderModuleList As <span style="color: #990000;">LIST_ENTRY</span><br />    InInitOrderModuleList As <span style="color: #990000;">LIST_ENTRY</span><br />    EntryInProgress As <span style="color: #990000;">Long</span><br /><span style="color: blue;">End Type</span></pre>
<br />
<ul>
   <li><b>(2)</b> Then it gets a pointer to get a pointer to the next "InLoadOrderModuleList/LIST_ENTRY" <code>MOV EAX, [EAX+0xC]</code>.</li>
</ul>
<pre><span style="color: blue;">Public Type</span> <span style="color: #990000;">LIST_ENTRY</span>    Flink As <span style="color: #990000;">LIST_ENTRY</span><br />    Blink As <span style="color: #990000;">LIST_ENTRY</span><br /><span style="color: blue;">End Type</span></pre>
<br />
<ul>
   <li><b>(3) and (4)</b> Then it navigates through the LIST_ENTRY linked list <code>MOV EAX, [EAX]</code>. This is done 2 times. First time, we get a pointer to the NTDLL.dll, second with get a pointer to the KERNEL.DLL. Each LIST_ENTRY is in fact followed by the structure LDR_MODULE : </li>
</ul>
<br />
<pre><span style="color: blue;">Public Type</span> LDR_MODULE<br />    InLoadOrderModuleList As LIST_ENTRY<br />    InMemoryOrderModuleList As LIST_ENTRY<br />    InInitOrderModuleList As LIST_ENTRY<br />    BaseAddress As Long<br />    EntryPoint As Long<br />    SizeOfImage As Long<br />    FullDllName As UNICODE_STRING<br />    BaseDllName As UNICODE_STRING<br />    Flags As Long<br />    LoadCount As Integer<br />    TlsIndex As Integer<br />    HashTableEntry As LIST_ENTRY<br />    TimeDateStamp As Long<br />    LoadedImports As Long<br />    EntryActivationContext As Long ‘ // ACTIVATION_CONTEXT<br />    PatchInformation As Long<br /><span style="color: blue;">End Type</span></pre>
<br />Then from the BaseAddress of the Kernel.dll module, crinkler is going to the section where functions are already loaded in memory. From there, the first hashed function that is stored by crinkler is LoadLibrary function. After this, crinkler is able to load all the depend dll and navigate through the import tables, recomputing the hash for all functions names for dependent dlls, and is trying to match the hash stored in the PE header. If a match is found, then the function entry point is stored.<br /><br />This way, crinkler is able to call some OS functions stored in the Kernel.DLL, without even linking explicitly to those DLL, as they are automatically loaded whenever a DLL is loaded. Thus achieving a way to import all functions used by an intro with a custom import loader.<br /><br />
<h2 id="results">Compression results </h2>
<br />So finally, you may ask, how much crinkler is good at compressing? How does it compare to other compression method? How does look like the entropy in a crinklerized exe?<br /><br />I'll take the example of Ergon exe. You can already find a <a href="http://code4k.blogspot.com/2010/08/making-of-ergon-4k-pc-intro.html#statistics">detailed analysis </a>for this particular exe.<br /><br />
<h3>Comparison with other compression methods</h3>
<br />In order to make a fair comparison between crinkler and other compressors, I have used the data that are actually compressed by crinkler after the reordering of code and data (This is done by unpacking a crinklerized ergon.exe and extracting only the compressed data). This comparison is accurate in that all compressors are using exactly the same data.<br /><br />In order also to be fair with crinkler, the size of 3652 is not taking into account the PE header + the crinkler decompressor code (which in total is 432 bytes for crinkler).<br /><br />To perform this comparison, I have only used 7z which has at least 3 interesting methods to test against :<br />
<ul>
   <li>Standard Deflate Zip</li>
   <li>PPMd with 256Mo of dictionary</li>
   <li>LZMA with 256Mo of dictionary</li>
</ul>
I have also included a comparison with a more advanced packing method from Matt Mahoney resource, <a href="http://mattmahoney.net/dc/paq.html#paq8">Paq8l </a>which is one of the version of PAQ methods, using neural networks and several context modeling methods.<br /><br />
<div align="center">
   <table border="0" cellpadding="0" cellspacing="0" style="width: 470px;">
      <tbody>
         <tr height="20" style="height: 15pt;">
            <td class="xl65" height="20" style="background: none repeat scroll 0% 0% rgb(192, 80, 77); border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color rgb(192, 80, 77); border-style: solid none none solid; border-width: 0.5pt medium medium 0.5pt; color: white; font-family: Calibri; font-size: 11pt; font-weight: 700; height: 15pt; text-decoration: none; width: 68pt;" width="91">Program</td>
            <td class="xl65" style="background: none repeat scroll 0% 0% rgb(192, 80, 77); border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: white; font-family: Calibri; font-size: 11pt; font-weight: 700; text-decoration: none; width: 131pt;" width="175">Compression   Method</td>
            <td class="xl65" style="background: none repeat scroll 0% 0% rgb(192, 80, 77); border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: white; font-family: Calibri; font-size: 11pt; font-weight: 700; text-decoration: none; width: 48pt;" width="64">Size in bytes</td>
            <td class="xl65" style="background: none repeat scroll 0% 0% rgb(192, 80, 77); border-color: rgb(192, 80, 77) rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid solid none none; border-width: 0.5pt 0.5pt medium medium; color: white; font-family: Calibri; font-size: 11pt; font-weight: 700; text-decoration: none; width: 105pt;" width="140">Ratio   vs Crinkler</td>
         </tr>
         <tr height="20" style="height: 15pt;">
            <td class="xl65" height="20" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color rgb(192, 80, 77); border-style: solid none none solid; border-width: 0.5pt medium medium 0.5pt; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; height: 15pt; text-decoration: none;">none</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">uncompressed</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">9796</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid solid none none; border-width: 0.5pt 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;"><br /></td>
         </tr>
         <tr height="20" style="height: 15pt;">
            <td class="xl65" height="20" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color rgb(192, 80, 77); border-style: solid none none solid; border-width: 0.5pt medium medium 0.5pt; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; height: 15pt; text-decoration: none;">crinkler</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">ctx-model 256Mo</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">3652</td>
            <td class="xl66" style="background: none repeat scroll 0% 0% rgb(124, 197, 124); border-color: rgb(192, 80, 77) rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid solid none none; border-width: 0.5pt 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">+0,00%</td>
         </tr>
         <tr height="20" style="height: 15pt;">
            <td class="xl65" height="20" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color rgb(192, 80, 77); border-style: solid none none solid; border-width: 0.5pt medium medium 0.5pt; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; height: 15pt; text-decoration: none;">7z</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">deflate 32Ko</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">4526</td>
            <td class="xl66" style="background: none repeat scroll 0% 0% rgb(248, 105, 107); border-color: rgb(192, 80, 77) rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid solid none none; border-width: 0.5pt 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">+23,93%</td>
         </tr>
         <tr height="20" style="height: 15pt;">
            <td class="xl65" height="20" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color rgb(192, 80, 77); border-style: solid none none solid; border-width: 0.5pt medium medium 0.5pt; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; height: 15pt; text-decoration: none;">7z</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">PPMd 256Mo</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">4334</td>
            <td class="xl66" style="background: none repeat scroll 0% 0% rgb(255, 235, 132); border-color: rgb(192, 80, 77) rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid solid none none; border-width: 0.5pt 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">+18,67%</td>
         </tr>
         <tr height="20" style="height: 15pt;">
            <td class="xl65" height="20" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color rgb(192, 80, 77); border-style: solid none none solid; border-width: 0.5pt medium medium 0.5pt; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; height: 15pt; text-decoration: none;">7z</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">LZMA 256Mo</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid none none; border-width: 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">4380</td>
            <td class="xl66" style="background: none repeat scroll 0% 0% rgb(254, 204, 127); border-color: rgb(192, 80, 77) rgb(192, 80, 77) -moz-use-text-color -moz-use-text-color; border-style: solid solid none none; border-width: 0.5pt 0.5pt medium medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">+19,93%</td>
         </tr>
         <tr height="20" style="height: 15pt;">
            <td class="xl65" height="20" style="border-color: rgb(192, 80, 77) -moz-use-text-color rgb(192, 80, 77) rgb(192, 80, 77); border-style: solid none solid solid; border-width: 0.5pt medium 0.5pt 0.5pt; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; height: 15pt; text-decoration: none;">Paq8l</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color; border-style: solid none; border-width: 0.5pt medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">dyn-ctx-model 256Mo</td>
            <td class="xl65" style="border-color: rgb(192, 80, 77) -moz-use-text-color; border-style: solid none; border-width: 0.5pt medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">3521</td>
            <td class="xl67" style="background: none repeat scroll 0% 0% rgb(99, 190, 123); border-color: rgb(192, 80, 77) rgb(192, 80, 77) rgb(192, 80, 77) -moz-use-text-color; border-style: solid solid solid none; border-width: 0.5pt 0.5pt 0.5pt medium; color: black; font-family: Calibri; font-size: 11pt; font-weight: 400; text-decoration: none;">-3,59%</td>
         </tr>
      </tbody>
   </table>
</div>
<br />As you can see, <b>crinkler is far more efficient than any of the "standard" compression method </b>(Zip, PPMd, LZMA). I'm not even talking about the fact that <b>a true comparison would be to include the decompressor size, so the ratio should certainly be worse for all standard methods!</b><br /><br />Paq8l is of course slightly better... but if you take into account that Paq8l decompressor is itself an exe of 37Ko... compare to the 220 byte of crinkler... you should understand now how much crinkler is highly efficient in its own domain! (remember? 4k!)<br /><br />
<h3>Entropy</h3>
<br />In order to measure the entropy of crinkler, I have developed a very small program in C# that is displaying the entropy of an exe. From green color (low entropy, less bits necessary to encode this information) to red color (high entropy, more bits necessary to encode this information).<br /><br />I have done this on 3 different ergon executable :<br />
<ul>
   <li>The uncompressed ergon.exe (28Ko). It is the standard output of a binary exe with MSVC++ 2008.</li>
   <li>The raw-crinklerized ergon.exe extracted code and data section, but not compressed (9796 bytes)</li>
   <li>The final crinklerized ergon.exe file (4070 bytes)</li>
</ul>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
   <tbody>
      <tr>
         <td style="text-align: center;"><a href="http://3.bp.blogspot.com/_dv_YkYWn3HA/TSSEdtWGygI/AAAAAAAADU8/Qfr3waKhqtY/s1600/entropy_ergon_plain_exe.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://3.bp.blogspot.com/_dv_YkYWn3HA/TSSEdtWGygI/AAAAAAAADU8/Qfr3waKhqtY/s320/entropy_ergon_plain_exe.jpg" width="320" /></a></td>
      </tr>
      <tr>
         <td class="tr-caption" style="text-align: center;">Ergon standard exe entropy</td>
      </tr>
   </tbody>
</table>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
   <tbody>
      <tr>
         <td style="text-align: center;"><a href="http://2.bp.blogspot.com/_dv_YkYWn3HA/TSSEh888-lI/AAAAAAAADVA/e0nr_iOO8YQ/s1600/entropy_ergon_codedata_reordered_and_pack.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://2.bp.blogspot.com/_dv_YkYWn3HA/TSSEh888-lI/AAAAAAAADVA/e0nr_iOO8YQ/s320/entropy_ergon_codedata_reordered_and_pack.jpg" width="320" /></a></td>
      </tr>
      <tr>
         <td class="tr-caption" style="text-align: center;">Ergon code and data crinklerized, uncompressed reordered data </td>
      </tr>
   </tbody>
</table>
<table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;">
   <tbody>
      <tr>
         <td style="text-align: center;"><a href="http://2.bp.blogspot.com/_dv_YkYWn3HA/TSSEkUZM1bI/AAAAAAAADVE/POtYP8cVBVw/s1600/entropy_ergon_crinklerized.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="320" src="http://2.bp.blogspot.com/_dv_YkYWn3HA/TSSEkUZM1bI/AAAAAAAADVE/POtYP8cVBVw/s320/entropy_ergon_crinklerized.jpg" width="320" /></a></td>
      </tr>
      <tr>
         <td class="tr-caption" style="text-align: center;">Ergon executable crinklerized</td>
      </tr>
   </tbody>
</table>
As expected, <b>the entropy is fairly massive in a crinklerized exe</b>. Compare with the waste of information in a standard windows executable. Also, you can appreciate how much is important the reordering and packing of data (no compression) that is perform by crinkler.<br /><br />
<h3>Some notes about the x86 crinkler decompressor asm code</h3>
<br />I have often talked about how much crinkler decompressor is truly a piece of x86 art.&nbsp; It is hard to describe the technique used here, there are lots of x86 standard optimization and some really nice trick. Most notably:<br />
<ol>
   <li><b>using all the registers</b></li>
   <li><b>using </b><b>intensively the stack to save/restore all the registers with pushad/popad x86</b>. This is for example done (1 + number_of_model) per bit. If you have 15 models, there will be a total of 16 pushad/popad instructions for a single bit to be decoded! You may wonder why making so many pushes? Its the only way to efficiently use all the registers (rule #1) without having to store particular registers in a buffer. Of course, push/pop instruction is also used at several places in the code as well.</li>
   <li>As a result of 1) and 2), apart from the hash dictionnary,<b> no intermediate structure are used to perform the context modeling calculation</b>.</li>
   <li><b>Deferred conditional jump</b>: Usually, when you perform some conditional testing with x86, this is often immediately followed by a conditional jump (like cmp eax, 0; jne go_for_bla). In crinkler, sometimes, a conditionnal test is done, and is used several instruction laters. (for example. cmp eax,0; push eax; mov eax, 5; jne go_for_bla &lt;---- this is using the result of cmp eax,0 comparison). It makes the code to read a LOT harder. Sometimes, the conditional is even used after a direct jump! This is probably one part of crinkler's decompressor that impressed me the most. This is of course something quite common if you are programming heavily optimized-size x86 asm code... you need to know of course which instructions is not modifying CPU flags in order to achieve this kind of optimization!</li>
</ol>
<br />
<h2>Final words</h2>
<br />I would like to apologize for the lack of charts, pictures to explain a little bit how things are working.&nbsp; This article is probably still obscure for a casual reader, and should be considered as a draft version. This was a quick and dirty post. I wanted to write this for a long time, so here it is, not perfect as it should be, but this may be improved in future versions! <br /><br />As you can see, crinkler is really worth to look at. The effort to make it so efficient is impressive and there is almost no doubt that there won't be any other crinkler competitor for a long time! At least for a 4k executable. Above 4k, I'm quite confident that there are still lots of area that could be improved, and probably kkrunchy is far from being the ultimate packer under 64k... Still, if you want a packer, you need to code it, and that's not so trivial!


    </div>
  </article>
</div>
<div class="col-sm-3">
  <nav class="js-toc toc sticky-top"></nav>
</div>
    </div>
  </div>
	<footer class="blog-footer">
        <p>Copyright &copy; 2009 - 2023, Alexandre Mutel - Blog content licensed under the Creative Commons <a href="http://creativecommons.org/licenses/by/2.5/">CC BY 2.5</a> | Site powered by <a href="https://github.com/lunet-io/lunet">lunet</a></p>
	</footer>  </body>
</html>