<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="lunet 0.4.2.0">
    <title>Stark - Language And Frontend Compiler - Prototype 2019 | xoofx</title>
    <link rel="stylesheet" href="/css/site.css">
    <script src="/js/site-defer.js" defer></script>
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@xoofx">
    <meta name="twitter:title" content="Stark - Language And Frontend Compiler - Prototype 2019 | xoofx">
    <meta name="twitter:description" content="This is the first part of the blog post series about The Odyssey of Stark and Melody and more specifically, about the development of the syntax of the Stark language and its front-end compiler, based on a fork of the C# Roslyn compiler, during its first year prototype last year. Overview The role of a compiler is to transform a higher level representation of some code to a lower level...">
    <meta name="twitter:image" content="https://xoofx.com/images/stark-driver.png">
    <meta name="twitter:image:alt" content="Stark - Language And Frontend Compiler - Prototype 2019 | xoofx">    
    <script src="https://www.googletagmanager.com/gtag/js?id=G-0DVR9ML8KY" async></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-0DVR9ML8KY');</script>
  </head>
  <body>

  <div class="container">
    <div class="row">
      <nav class="navbar navbar-expand-md navbar-light w-100">
            <a class="xoofx-logo navbar-brand" href="/"></a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
            </button>
            <div id="navbarSupportedContent" class="collapse navbar-collapse justify-content-between">
<ol id='nav-id-home-0' class='navbar-nav nav-level0  w-100'>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/' class='nav-link  '>Home</a></span>  </li>
  <li class='nav-item  active'>
    <span class='nav-item-row'><a href='/blog/' class='nav-link  '>Blog</a></span>  </li>
  <li class='nav-item '>
    <span class='nav-item-row'><a href='/projects/' class='nav-link  '>Projects</a></span>  </li>
  <li class='nav-item  ml-auto'>
    <span class='nav-item-row'><a href='/about/' class='nav-link  '>About</a></span>  </li>
</ol>
            </div>            
      </nav>
    </div>
    <div class="row">
      
<div class="col-sm-9 js-toc-content">
  <p id="lunet-results"></p>
  <article class="page">
    <div class="title">
		  <h1 class="title"><a href="/blog/2020/03/06/stark-language-frontend-compiler/">Stark - Language And Frontend Compiler - Prototype 2019</a></h1>
		<span class="subtitle">Syntax of the language and the development of the front-end compiler</span>
    </div>
    <div class="entry-content">
    <div class="blog-post-meta">
      <span class="fa fa-calendar"></span>
      <span class="date"><time datetime="2020-03-06" itemprop="datePublished">March  6, 2020</time></span>
      <i class="fa fa-tags"></i><a href="/blog/tag/stark/">Stark</a>, <a href="/blog/tag/melody/">Melody</a>, <a href="/blog/tag/os/">OS</a>, <a href="/blog/tag/compiler/">Compiler</a>, <a href="/blog/tag/llvm/">LLVM</a>, <a href="/blog/tag/csharp/">C#</a>, <a href="/blog/tag/net/">.NET</a>
  	  <span class="fa fa-edit"></span> <a href="https://github.com/xoofx/xoofx.github.io/edit/master/blog/2020-03-06-stark-language-frontend-compiler.md">edit</a>
    </div>
      <p>This is the first part of the blog post series about <a href="/blog/2020/03/05/stark-melody-dotnet-sel4">The Odyssey of Stark and Melody</a> and more specifically, about the development of the syntax of the <a href="https://github.com/stark-lang/stark">Stark</a> language and its front-end compiler, based on a fork of the <a href="https://github.com/dotnet/roslyn">C# Roslyn compiler</a>, during its first year prototype last year.</p>
<h2 id="overview">Overview</h2>
<img src="/images/stark-driver.png" class="mx-auto" style="display: block"/>
<p>The role of a compiler is to transform a higher level representation of some code to a lower level representation, up to an ultimate representation into executable machine code.</p>
<p>This refinement doesn't have to be in one step (e.g source language to native code directly) and actually, it makes more sense to do it in several steps, because we can bring more - build and compile time - optimization opportunities along these steps, while it is also simplifying the domain problem on each refinement steps.</p>
<p>To that end, the .NET ecosystem is giving a good basis to work with: a .NET assembly is an intermediate binary representation of source code (following the well defined <a href="https://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335 specifications</a>) and it brings several key features:</p>
<ul>
<li>Its format is compact and you can almost represent any code with it (e.g including C++ code).</li>
<li>It contains both the interface of your code and the implementation, encoded in a binary format that stills keep track of high level types, method signatures, contracts...</li>
<li>It doesn't enforce rules about inline-ability, all your code is there, you can decide later how you want to project it (debug vs release, -O2 vs -O3)</li>
<li>It can contain compile time attributes that can be used by other post-processing tools or native compilers.</li>
<li>There are multiple tools - OSS and commercial - to inspect them: <a href="https://github.com/icsharpcode/ILSpy">ILSpy</a>, <a href="https://github.com/0xd4d/dnSpy">dnSpy</a>, <a href="https://www.jetbrains.com/decompiler/">dotPeek</a>...</li>
<li>There are .NET libraries to manipulate them: <a href="https://github.com/jbevain/cecil">Mono.Cecil</a>, <a href="https://github.com/dotnet/corefx/tree/master/src/System.Reflection.Metadata">System.Reflection.Metadata</a>...</li>
<li>It is a proven technology used by several existing compilers (e.g Roslyn for C#/VB, or F# compiler)</li>
<li>It not only meant to transport a compact representation of your code but also an easier way for a native compiler to transform it to native code later, and to make better codegen decisions.</li>
</ul>
<p>For Stark, I would like the entire build, compile, tests, benchmarks and package pipeline to be as much as stream-lined, integrated and efficient as possible, in order to provide a great development experience. The idea would be to have a <code>stark</code> driver command that is able to do all of this efficiently. For instance, unlike the .NET ecosystem that relies on msbuild, I would prefer this driver to leverage more potential build time optimizations - by using a persistent compiler driver/server for the full toolchain, including support for intellisense. So when today there is <code>starkc</code> command, ultimately, this command will be part of a larger compiler server that will integrate with package, native compilation...</p>
<p>Reusing the infrastructure provided by .NET assembly fits perfectly into this picture. The frontend compiler would be responsible to transform Stark language source code into <code>sklib</code> files (which would be similar to .NET assembly). Maybe later we can rethink of a more optimized format for storing its IR (optimized for faster codegen), but for now, it's already good enough.</p>
<p>Then, the obvious challenge is to transform source code to an <code>sklib</code> Library through a front-end compiler (the green part in the diagram above), but developing such a compiler for an individual is barely achievable. So instead of taking that long and uncertain route, and thanks again to the .NET ecosystem, we could leverage on an existing, strong (and complex!) compiler like Roslyn to kickstart this work.</p>
<p>I had already some good experience with Roslyn, but to my knowledge, nobody ever tried to reuse it to develop a completely new language with it for a different and new platform (or even an OS), so that was the goal of this first year: transform Roslyn to support a new language with a different syntax while keeping its &quot;imperative&quot; language class nature (meaning that we can't modify fundamentally how type inference is achieved for example).</p>
<p>So let's see how the Stark language has been prototyped during this first year with a fork of Roslyn.</p>
<h2 id="based-on-roslyn">Based on Roslyn</h2>
<p>Changing Roslyn to create a new language is very challenging for several reasons:</p>
<ul>
<li>The codebase is huge, years of development, with 2 languages C# and VB.</li>
<li>The repository is itself compiled with preview of Roslyn fetched from internal NuGet feeds.</li>
<li>The projects have lots of dependencies over the VisualStudio SDK and again preview versions.</li>
<li>Projects have lots of dependencies, one change in a core project might lead to change 1000+ references in the entire codebase.</li>
<li>The codebase is evolving, new features, bug fixes coming upstream. Even if the public API doesn't change much, the internals can.</li>
<li>Some design decisions made very early in the development of Roslyn are making changes a lot more laborious. Example:
<ul>
<li>ref types are not represented by a proper type, so a ref kind has to be propagated all over the places along its associated type</li>
<li>Nullable types are put in a thin struct wrapper around real types. They are also not a proper types in the system.</li>
</ul>
</li>
</ul>
<p>In order to make some progress for prototyping a new language, I had to cut lots of existing code and take hard decisions:</p>
<ul>
<li>I had to remove VB to avoid having to maintain the changes I was making on the C# and core parts of the compiler.</li>
<li>I had to rename namespaces (e.g <code>CSharp</code> =&gt; <code>Stark</code>)</li>
<li>After a few months trying to <a href="https://github.com/stark-lang/stark-roslyn">keep the fork</a> up-to-date with upstream, I made a <a href="https://github.com/stark-lang/stark/commit/d74fe898c3babb5cf4b407aa53edd7c576cad50c">hard fork</a>
<ul>
<li>Because I was also making changes to <code>System.Reflection.Metadata</code> which was in the CoreFx repository, the sync was becoming impossible.</li>
<li>The hard fork allowed me to remove the internal NuGet feeds and complex build pipeline of Roslyn by using a regular .NET Standard 2.0 project without any custom NuGet packages.</li>
<li>After trying to maintain Visual Studio Roslyn Integration, I also removed it: This was a tough decision, but this part is too difficult to keep-up with, and it brings a complexity that I couldn't maintain on my own. I decided that providing a good integration with <code>Visual Studio Code</code> would be much easier for the project in the medium term.</li>
</ul>
</li>
<li>I removed all the existing tests: This was also too difficult to maintain while prototyping a new syntax. I decided that I would use during the beginning the runtime of stark as a &quot;testing suite&quot;. For this reason, the runtime is maintained in the same repository under <code>src/runtime</code> folder
<ul>
<li>A change to the syntax is now sync with the change to the runtime. It makes iteration vastly easier.</li>
<li>Tests will be re-introduced later once the syntax is a bit more stable. Nonetheless, that will be a huge work and some help will be much welcome!</li>
</ul>
</li>
</ul>
<p>The front-end compiler and runtime of Stark are hosted on <a href="https://github.com/stark-lang/stark">https://github.com/stark-lang/stark</a></p>
<h2 id="leaner-syntax">Leaner syntax</h2>
<p>Most of the early changes concerned only <code>LanguageParser.cs</code> (the lexer/parser) in Roslyn codebase and it was the easiest place to start with and to see how difficult it would be to change the syntax.</p>
<p>As I discovered and explained in my previous posts about the Stark Language syntax, a lean syntax here might be appealing for some but not for others. It highly depends on your personal taste and experience with languages, how long have you been using some particular syntaxes, if you have been navigating between multiple languages and different paradigm (e.g functional vs imperative)... There is no such thing as &quot;natural&quot; programming syntax but there are lots of religion and way of thinking around existing programing languages. So by no surprise, Stark syntax is mostly colored by my personal relation with programing languages and by what I have seen during my career.</p>
<p>Typically, one of the very first change I made was to remove the need for semi-colon <code>;</code> (as Swift Language did for example) but I have kept braces <code>{</code> and <code>}</code>, while I also removed the need for using parenthesis with control flows.</p>
<p>Originally for Stark, I had a plan to use space sensitive language (like python or F#), but realized that it would be too painful to retrofit in Roslyn and by the fact also that braces can allow compact syntaxes (specially with closures) that are difficult to express without.</p>
<p>Then I started to bring some more important syntax changes:</p>
<ul>
<li><p>Use of <code>import</code> keyword instead of <code>using</code> to import namespaces</p>
</li>
<li><p>Introduction of modules like in F# (static class in C#) but they would work the same way with <code>import</code> (no need to say <code>import static</code>)</p>
<pre><code class="language-stark">// Import namespace core
import core
// Import module core.runtime
import core.runtime

// Declare an empty module
public module my_module { }
</code></pre>
<p>The introduction of module as first class construction is important to make also functions first class.</p>
</li>
<li><p>Only one <code>namespace</code> per file, namespace would not require braces and should come first in the file. This is similar to Java for instance.</p>
<pre><code class="language-stark">namespace core

public virtual class Object {
    private unsafe let _type : Type
    public constructor() {
    }
}
</code></pre>
</li>
<li><p>Use of the keyword <code>constructor</code> for declaring a constructor.</p>
</li>
<li><p>Use of a simple <a href="https://github.com/stark-lang/stark/blob/master/doc/naming-conventions.md">naming convention</a> derived from Rust:</p>
<ul>
<li>Using <code>UpperCamelCase</code> for &quot;type-level&quot; constructs (class, struct, enum, interface, union, extension)</li>
<li>And <code>snake_case</code> for &quot;value-level&quot; constructs</li>
<li>A departure from C# is that modules and namespaces are following <code>snake_case</code>
<br></li>
</ul>
<p>| Item | Convention |
| ---- | ---------- |
| Package | <code>snake_case</code> (but prefer single word) |
| Namespace | <code>snake_case</code> (but prefer single word) |
| Module | <code>snake_case</code> (but prefer single word) |
| Types: class, struct, interface, enum, union | <code>UpperCamelCase</code> |
| Union cases | <code>UpperCamelCase</code> |
| Functions | <code>snake_case</code> |
| Local variables | <code>snake_case</code> |
| Static variables | <code>SCREAMING_SNAKE_CASE</code> |
| Constant variables | <code>SCREAMING_SNAKE_CASE</code> |
| Enum items | <code>SCREAMING_SNAKE_CASE</code> |
| Type parameters | concise <code>UpperCamelCase</code>, prefixed by single uppercase letter: <code>T</code> |
</p>
</li>
<li><p>Use of a more uniform naming for primitive types, following the syntax of Rust:</p>
<p>| C# | Stark |
| ---- | ---------- |
| <code>bool</code> | <code>bool</code> |
| <code>byte</code> | <code>u8</code> |
| <code>sbyte</code> | <code>i8</code> |
| <code>short</code> | <code>i16</code> |
| <code>ushort</code> | <code>u16</code> |
| <code>int</code> | <code>i32</code> |
| <code>uint</code> | <code>u32</code> |
| <code>long</code> | <code>i64</code> |
| <code>ulong</code> | <code>u64</code> |
| <code>System.IntPtr</code> | <code>int</code> |
| <code>Systme.UIntPtr</code> | <code>uint</code> |
| <code>float</code> | <code>f32</code> |
| <code>double</code> | <code>f64</code> |
| <code>object</code> | <code>object</code> |
| <code>string</code> | <code>string</code> |
</p>
<p><br>You will notice that <code>int</code> and <code>uint</code> represents actually native integers (e.g an <code>int</code> is an <code>i32</code> or <code>i64</code> depending if the target CPU 32 or 64 bits). In Stark, they are first class types and are for example used as the default type for array/collection size/indexers.</p>
</li>
<li><p>Use of <code>implements</code> interface inheritance/prototype contracts and <code>extends</code> for sub-classing, similar to Java.</p>
<pre><code class="language-stark">namespace core
public abstract class Array implements ISizeable {}
</code></pre>
<pre><code class="language-stark">namespace core
import core.runtime

/// Base class for an exception
public abstract immutable class Exception extends Error {
    protected constructor() {
    }
}
</code></pre>
</li>
<li><p>Use of <code>virtual</code> on class definition to specify that they can be sub-classed. They are <code>sealed</code> (in C# terminology) by default.</p>
</li>
<li><p>Use of only one syntax for <code>for</code> which would be equivalent of the <code>foreach</code> syntax in C#</p>
<pre><code class="language-stark">public static func sun_range(range: Range) -&gt; int {
    var result : int = 141
    for x in range {
        result += x
    }
    return result
}
</code></pre>
<p>For iterating over an integer range (e.g <code>for(int i = 0; i &lt; array.size; i++)</code>) the equivalent in Stark is to use the Range syntax as a Range in Stark is iterable:</p>
<pre><code class="language-stark">public static func sun_range(array: []u8) -&gt; int {
    var result : int = 0
    for i in 0..&lt;array.size {
        result += array[i]
    }
    return result
}
</code></pre>
</li>
<li><p>Mandatory braces <code>{</code> and <code>}</code> for all control flows</p>
</li>
<li><p>Left to right syntax, to simplify parsing and to make reading &quot;left to right&quot; matching what you are actually writing in the code (similar to Go lang):</p>
<ul>
<li>A function declaration is: <code>public func myfunction() {}</code></li>
<li>A variable declaration is <code>var x = 5</code></li>
<li>A variable declaration with single assignment is <code>let y = &quot;test&quot;</code></li>
<li>An array of unsigned 8 bits is <code>[]u8</code></li>
<li>An optional object <code>?object</code></li>
<li>An optional array of optional string is <code>?[]?string</code></li>
</ul>
</li>
<li><p>Make parameters declaration name first and then type, separated by a <code>:</code> colon</p>
</li>
</ul>
<pre><code class="language-stark">public static func process_elements(array: []u8, offset: int, length: int) -&gt; int {
    // ...
}
</code></pre>
<ul>
<li>Casting between types is using the <code>as</code> syntax:
<pre><code class="language-stark">var a_float = 123 as f32
var an_int = 1.5 as int
</code></pre>
</li>
<li>Variable/field assignment: <code>var</code> for multiple assignments, <code>let</code> for single assignment.
<pre><code class="language-stark">var this_is_a_var = 123
let this_is_a_let = 124
this_is_a_var = 5
// this_is_a_let = 6 // Can't assign again for let
</code></pre>
</li>
<li>Add if/then/else expression instead of C# ternary <code>cond ? value_true : value_false</code>:
<pre><code class="language-stark">// if in an expression
var result = if cond then 1 else 2

// If as a statement
if cond then {
  // ...
} else {
  // ...
}
</code></pre>
</li>
<li>Attribute syntax is following the Java attributes prefixed by <code>@</code>. You can still have multiple attributes but they don't need to be enclosed within brackets and separated by commas.
<pre><code class="language-stark">@AttributeUsage(AttributeTargets.PARAMETER)
@ThisIsAnotherWithoutParenthesis
public class MyAttribute extends Attribute {
    public constructor() {}
}
</code></pre>
</li>
</ul>
<h2 id="remove-boxing-and-object-default-methods">Remove boxing and object default methods</h2>
<p>In Stark, boxing a value-type automatically to a managed object is no longer possible. You can't cast an <code>int</code> to an <code>object</code>, so you can't allocate accidentally on the heap.</p>
<p>The collateral effect of this change is also that you can't cast a struct to an interface even if that struct implements that interface. If you need to call a struct through an interface, it has to go through a generic constraint call.</p>
<p>Also consequently, all the default virtual methods inherited by all objects were removed from <code>object</code> class definition:</p>
<ul>
<li><code>~object()</code> destructor</li>
<li><code>bool Equals(object)</code></li>
<li><code>int GetHashCode()</code></li>
<li><code>string ToString()</code></li>
</ul>
<p>It should help to have a smaller footprint for runtime metadata for reference types. The VTable for objects in Stark would be empty by default.</p>
<p>An important benefit of these changes is that pointers can now be used as generic arguments:</p>
<pre><code class="language-stark">var list = new List&lt;*u8&gt;() // declare a list of pointer to u8
</code></pre>
<p>(Because in regular ECMA-335, pointers are not inheriting from <code>System.ValueType</code> and so they cannot be boxed)</p>
<blockquote>
<p>You may wonder why it is important to have that support: It can be useful if you are developing low level parts in a kernel OS where you don't have yet a GC running but you still want to use container classes to manipulate kernel objects and structures.</p>
</blockquote>
<h2 id="arrays">Arrays</h2>
<p>First, array co-variance is one of the big legacy design decision that is now possible to revisit in Stark.</p>
<p>In C#, Arrays are co-variant, meaning that this is possible:</p>
<pre><code class="language-c#">var array_of_string = new string[] { &quot;a&quot;, &quot;b&quot; };
var array_of_object = (object[])array_of_string;
array_of_object[0] = 1; // will result in a runtime cast error
</code></pre>
<p>Not only it can be error prone but it has a cost at runtime, as an array write access can lead to perform a type cast check.</p>
<p>In Stark, arrays are no longer co-variant.</p>
<blockquote>
<p>Note: This is not yet implemented in the front-end compiler but should not be much trouble to bring.</p>
</blockquote>
<p>Also, any array like data are sharing the same base interface <code>IArray&lt;T&gt;</code>, that defines the minimal contract for an array: the size property, ref indexer and the assumption that the data are sequential in memory. The following types are all inheriting from <code>IArray&lt;T&gt;</code></p>
<ul>
<li>Managed arrays (e.g <code>[]u8</code>)</li>
<li>String</li>
<li>Fixed arrays (e.g <code>fixed [4]u8</code>)</li>
<li>Slices (e,g <code>~[]u8</code>)</li>
</ul>
<h2 id="strings">Strings</h2>
<p>A <a href="https://github.com/stark-lang/stark/blob/master/src/runtime/core/String.sk">String in Stark</a> is UTF8 by default. It is even just a sequence of byte and the string type is actually a small struct wrapping this byte buffer:</p>
<pre><code class="language-stark">namespace core

/// A string is a struct wrapping an array of u8
/// Can be mutable or immutable/readable and sharing
/// the same interface as arrays
public struct String implements IArray&lt;u8&gt; {
    private let _buffer : []u8

    public constructor(size: int)
        requires size &gt;= 0 {
        _buffer = new [size]u8
    }

    public constructor(buffer: []u8) {
        _buffer = buffer
    }

    // ...
}
</code></pre>
<p>This is very similar to what has been adopted for <a href="https://blog.golang.org/strings">strings in GoLang</a>.</p>
<p>The type <code>char</code> has been also replaced by the type <code>rune</code> which has the size of an <code>i32</code> (unicode codepoint).</p>
<h2 id="fixed-arrays-and-generic-literals">Fixed Arrays and generic literals</h2>
<p>In C#, generic parameters are only meant to be Type definitions. You can't design something like <code>SmallList&lt;T, 5&gt;</code> where the implementation would store 5 consecutive T elements or overflow to a managed array if there is not enough room.</p>
<blockquote>
<p>Generic literals are critical to introduce more efficient algorithms usually for performance reasons (e.g specialized codegen) and to improve locality (e.g fixed amount of co-located data).</p>
</blockquote>
<p>In Stark, It is possible to add a generic parameter constraint to expect a const literal primitive (e.g <code>const int</code>). For example, a fixed array in Stark is declared like this:</p>
<pre><code class="language-stark">namespace core
import core.runtime

public struct FixedArray&lt;T, tSize&gt; implements IArray&lt;T&gt; where tSize: is const int
{
    // The array cannot be initialized by using directly this class
    private constructor() {}

    // size is readable
    public func size -&gt; int =&gt; tSize

    // ...
}
</code></pre>
<p>It is then possible to use fixed array with the following syntax:</p>
<pre><code class="language-stark">public class PlayFixedArray {
    // Declare a field with a fixed size array
    public var field_table: [4]int

    // Fixed size array of objects
    public var field_table_of_objects: [3]object
}

public module fixedarray_playground {
    public static func play_with_fixed(cls: PlayFixedArray, 
                                       fixed_array_by_ref: ref [2]int) -&gt; int {
        // Fixed size array access
        return cls.field_table[0] + fixed_array_by_ref[1]
    }
}    
</code></pre>
<blockquote>
<p>Note: The syntax is not definitive, as it could conflict with normal array (e.g in case we want to allocate a managed array on the stack), it is more likely that fixed array will require a prefix e.g <code>fixed []u8</code> or different syntax (but then more cryptic).</p>
</blockquote>
<p>This type can then be reused in higher level containers (e.g <code>SmallList&lt;T, tSize&gt;</code>)</p>
<p>The <code>FixedArray</code> type is also a special case for the native compiler. As you can see above, the struct doesn't contain any field declarations, but the native compiler will generate them when the struct is being used.</p>
<p>At the IL level, I had to modify ECMA-335 to introduce a new generic type literal reference and also a new IL opcode to load its value. For instance the property <code>public func size -&gt; int =&gt; tSize</code> which is returning the <code>tSize</code> generic argument is translated at the IL level to a new opcode <code>ldtarg    !tSize</code>:</p>
<pre><code class="language-c#">	// Token: 0x06000035 RID: 53 RVA: 0x0000240B File Offset: 0x0000060B
	.method public final hidebysig specialname newslot virtual 
		instance native int get_size () cil managed 
	{
		// Header Size: 1 byte
		// Code Size: 6 (0x6) bytes
		.maxstack 8

		/* 0x0000060C E11200001B   */ IL_0000: ldtarg    !tSize
		/* 0x00000611 2A           */ IL_0005: ret
	} // end of method FixedArray`2::get_size
</code></pre>
<p>Though, there are still challenges ahead related to how far we will allow to create const literals from const expressions:</p>
<pre><code class="language-stark">public struct HalfFixedArray&lt;T, tSize&gt;  where tSize: is const int {
    // Some challenge ahead to store this computation at IL level
    public var field_table: [tSize / 2 + 1]T
}
</code></pre>
<h2 id="iterator">Iterator</h2>
<p>In .NET, the <code>IEnumerable&lt;T&gt;</code> provides a pattern to iterate on a sequence of elements and mostly relevant when used in conjunction with the <code>foreach</code> syntax. In <a href="https://blog.paranoidcoding.com/2014/08/19/rethinking-enumerable.html">Rethinking Enumerable</a> Jared Parsons explained what is not working well with <code>IEnumerable&lt;T&gt;</code> and explored a different way of iterating on elements.</p>
<p>For the same reasons, Stark is departing from .NET <code>IEnumerable&lt;T&gt;</code> by introducing <code>Iterable&lt;T, TIterator&gt;</code>, where <code>TIterator</code> contains the state of the iteration:</p>
<pre><code class="language-stark">namespace core

/// Base interface for iterable items
public interface Iterable&lt;out T, TIterator&gt;
{
    /// Starts the iterator
    readable func iterate_begin() -&gt; TIterator

    /// Returns true if the iterable has a current element
    readable func iterate_has_current(iterator: ref TIterator) -&gt; bool 

    /// Returns the current element
    readable func iterate_current(iterator: ref TIterator) -&gt; T

    /// Moves the iterator to the next element
    readable func iterate_next(iterator: ref TIterator)

    /// Ends the iterator
    readable func iterate_end(iterator: ref TIterator)
}
</code></pre>
<p>And it's usage in Stark is no different than in C# with <code>foreach</code>:</p>
<pre><code class="language-stark">public static func sum(indices: List&lt;int&gt;) -&gt; int {
    var result : int = 0
    for x in indices {
        result += x
    }
    return result
}
</code></pre>
<p>In the case of <code>List&lt;int&gt;</code> the iterator state is simply an integer, the index of the element.</p>
<p>The generated code under the hood is doing something like this:</p>
<pre><code class="language-stark">public static func sum(indices: List&lt;int&gt;) -&gt; int {
    var result : int = 0
    var iterator = indices.iterate_begin()
    while indices.iterate_has_current(ref iterator) {
        var x = indices.iterate_current(ref iterator)
        result += x
        indices.iterate_next(ref iterator)
    }
    indices.iterate_end(ref iterator)

    return result
}
</code></pre>
<p>The implementation for <code>List&lt;T&gt;</code> would inherit from <code>Iterable&lt;T, int&gt;</code> with the methods:</p>
<pre><code class="language-stark">    readable func Iterable&lt;T, int&gt;.iterate_begin() -&gt; int =&gt; 0

    readable func Iterable&lt;T, int&gt;.iterate_has_current(index: ref int) -&gt; bool =&gt; index &lt; size

    readable func Iterable&lt;T, int&gt;.iterate_current(index: ref int) -&gt; T =&gt; this[index]

    readable func Iterable&lt;T, int&gt;.iterate_next(index: ref int) =&gt; index++

    readable func Iterable&lt;T, int&gt;.iterate_end(state: ref int) {}
</code></pre>
<p>The major benefits of using such a pattern:</p>
<ul>
<li>The iterator state is separated and can be a value-type.</li>
<li>The generated code doesn't box (in C# you would have to create duck typing GetEnumerator() method to workaround it).</li>
<li>The implementation is simple and straightforward, no need for an extra-type (e.g the Enumerator). Many iterators on indexed containers can use the iterator state <code>int</code>.</li>
<li>Implementing <code>Linq</code> over this iterator should allow to generate efficient inlined code.</li>
<li>The <code>try</code>/<code>finally</code> would be triggered only if the iterator inherits from <code>IDisposable</code> (not implemented in the current prototype).</li>
<li>It could also support mutable iterator (an mutable_iterate_current that return a ref)</li>
</ul>
<blockquote>
<p>Note that it is a first try at implementing differently an iterator. An objection to this design is the need to have 3 methods (<code>has_current</code>, <code>current</code>, <code>next</code>) to implement something that could be implemented in a single method call:</p>
<pre><code class="language-stark">func iterable_next(iterator: ref TIterator) -&gt; ?T
</code></pre>
<p>This single method approach makes it easier to decide in one go if it can continue and fetch the value at the same time.
But it also complicates the iterator state implementation: For an array index, it would have to start at -1, and in next, would have to check <code>index + 1</code> against <code>size</code>. The return value would also have to be returned for the end-of-iterator, a big struct <code>T</code> even if wrapped through an optional <code>?T</code> could still take precious CPU cycles for an empty iterator.</p>
<p>So the design is still open to debate.</p>
</blockquote>
<h2 id="range-and-slice">Range and Slice</h2>
<p>Unlike in C#, Ranges in Stark are iterate-able and are supported by <code>for</code> loop iteration (<code>foreach</code> in C#). This helps also to remove the C <code>for</code> legacy loop construction.</p>
<p>A <code>Range</code> in stark is inclusive, so <code>0..1</code> would contain 0 and 1.</p>
<pre><code class="language-stark">public static func sun_range() -&gt; int {
    var result : int = 0
    // iterates from -1 to 1 inclusive
    for x in -1..1 {
        result += x
    }
    return result // returns 0
}
</code></pre>
<p>In order to iterate on an array by using its length, you can use the syntax <code>0..&lt;array.size</code> and it would create a range that is <code>0..(array.size-1)</code>:</p>
<pre><code class="language-stark">public static func sun_range(array: []u8) -&gt; int {
    var result : int = 0
    for i in 0..&lt;array.size {
        result += array[i]
    }
    return result
}
</code></pre>
<blockquote>
<p>Note that there is a design flaw between Iterable and Range that makes it not possible to iterate from <code>int.min_value..int.max_value</code></p>
</blockquote>
<p>Ranges are more useful for creating slices from existing data. In C#, when a range is used with an indexer on a string or an array, it will create a copy of the original data, with a hidden heap allocation.</p>
<p>Stark is introducing the struct <code>Slice&lt;TArray, T&gt;</code> where <code>TArray</code> is an <code>IArray&lt;T&gt;</code> that provides a view (and not a copy) around an existing struct/class implementing the <code>IArray&lt;T&gt;</code> interface. The syntax is using the prefix tilde <code>~</code>. A slice of an array of <code>u8</code> can be expressed as <code>~[]u8</code> that translates to <code>Slice&lt;[]u8, u8&gt;</code>:</p>
<pre><code class="language-stark">/// return the slice &quot;abcd&quot;
public static func get_slice_with_string() -&gt; ~string =&gt; &quot;abcd&quot;

/// return the slice &quot;ab&quot;
public static func get_slice_with_string_range() -&gt; ~string =&gt; &quot;abcd&quot;[0..1]

/// return a slice of a slice from a slice
public static func get_slice_of_slice(slice: ~string) -&gt; ~string =&gt; slice[0..2][0..1]

/// return a slice from an array
public static func get_slice_with_array(array: []int) -&gt; ~[]int =&gt;  array[0..1]
</code></pre>
<h2 id="the-error-model">The error model</h2>
<p>In order to differentiate non-recoverable programming errors from OS/user exceptions (e.g IO), the error model of Stark is following the feedback from <a href="http://joeduffyblog.com/2016/02/07/the-error-model/">Midori - The Error Model</a></p>
<ul>
<li>Aborts are non-recoverable errors that can be either:
<ul>
<li>Generated errors by contract at compile time</li>
<li>Runtime errors when it is not possible to detect this at compile time</li>
<li>Explicit aborts via runtime asserts</li>
</ul>
</li>
<li>Checked exceptions for OS/user exceptions (e.g IO)</li>
</ul>
<pre><code class="language-stark">namespace core
import core.runtime

public interface IArray&lt;T&gt; extends ISizeable, MutableIterable&lt;T, int&gt; {
    /// ref indexer #2, not readable
    func operator [index: int] -&gt; ref T 
        requires index &gt;= 0 &amp;&amp; index &lt; size { 
          get 
    }
}
</code></pre>
<blockquote>
<p>Note that while the parser is currently accepting this syntax, the work to fully support this has not been done yet</p>
<p>It will require to store the IL instructions for the <code>requires</code> clause, as well as having a simplified interpreter at compile time and fallback to a runtime error if not possible.</p>
</blockquote>
<p>And for checked exceptions, the syntax is following the Java syntax:</p>
<pre><code class="language-stark">    // Valid (throws declared)
  public static func throw_my_exception() throws MyException {
      throw new MyException()
  }

  // Calling a method that throws without `try method()` is invalid
  public static func call_a_method_which_throws_invalid() {
      throw_my_exception() // generates a compiler error
  }

  // Valid (try with method throwing an exception)
  public static func try_a_method_which_throws() throws Exception {
      try throw_my_exception()
  }

  // Catching an exception does not require throws on method
  public static func try_a_method_which_throws_but_is_caught() {
      try {
          try throw_my_exception()
      } catch (MyException ex) {          
          // We don't rethrow  
      }
  }
</code></pre>
<p>Exceptions need to be caught or declared on the method. Later Stark will also support <code>try</code> expression with <code>Result&lt;T&gt;</code> which will allow to perform pattern matching on it, to extract the exception or the result value of a method call.</p>
<h2 id="unsafe-il">Unsafe IL</h2>
<p>Even if a language provides high-level constructs and safety, it requires often unrestricted access in order to provide safety (!) or more efficient code. These unsafe usages can still be abstracted and wrapped.</p>
<p>In C#, there is no easy support for that, so these days, you need to either:</p>
<ul>
<li>Use <code>System.Runtime.CompilerServices.Unsafe</code> though you can't do everything and it is bound to what is exposed</li>
<li>Use a solution like <a href="https://github.com/Fody/Fody">Fody</a> coupled with <a href="https://github.com/ltrzesniewski/InlineIL.Fody">InlineIL.Fody</a></li>
</ul>
<p>In the F# code library, the F# compiler is allowing to inline IL with the syntax <code>(# ... #)</code> and it is <a href="https://github.com/fsharp/fsharp/blob/6819e1c769269edefcea2263c98f993e90b623e2/src/fsharp/FSharp.Core/prim-types.fs#L400-L467">used internally</a> to unlock some low level parts that cannot be expressed in F#. In the past it was even allowed for user library, but I have read somewhere that it is no longer possible, which is fine in my opinion, as long as the language and runtime in the end are able to fill all the necessary missing gaps.</p>
<p>In the CoreRT compiler, they had to develop IL post processing (similar to Fody) to <a href="https://github.com/dotnet/corert/blob/3c58e6d6a41a64d8742535c653088a7629ce879c/src/Common/src/TypeSystem/IL/Stubs/UnsafeIntrinsics.cs#L13-L90">patch some methods like Unsafe utility methods</a>.</p>
<p>In Stark, I have decided to bring back to life the old prototype <a href="https://xoofx.com/blog/2016/05/25/inline-il-asm-in-csharp-with-roslyn/">Inline IL ASM in C# with Roslyn</a> and improved its integration by allowing a new <code>unsafe il</code> syntax:</p>
<pre><code class="language-stark">public func operator [index: int] -&gt; ref T
    requires index as uint &lt; tSize as uint
  { 
    get {
        unsafe il {
            ldarg.0
            ldarg.1
            sizeof T
            conv.i
            mul
            add
            ret
        }
    } 
}
</code></pre>
<h2 id="others">Others</h2>
<p>During this first year, a few other areas were experimented or partially prototyped:</p>
<ul>
<li><p><code>RuntimeExport</code>/<code>RuntimeImport</code> symbol binding: these are attributes that you can put on static methods providing dynamic weak static linking between low level parts in the language and their runtime projections:</p>
<pre><code class="language-stark">// In a first library A
@RuntimeImport
public extern static func allocate_object_heap(type: Type) -&gt; object;

// In a second library B that provides the implementation of allocate_object_heap
@RuntimeExport(&quot;allocate_object_heap&quot;)
public extern static func allocate_object_heap_x86(type: Type) -&gt; object;
</code></pre>
</li>
<li><p>Parameter less constructor for structs. In Stark, structs can declare a default constructor. This is especially important to support such a feature for correct support of safe object reference (no null)</p>
<pre><code class="language-stark">public struct MyStruct { public constructor() { ... } }
</code></pre>
</li>
<li><p>In addition to the existing attributes <code>CallerFilePath</code>, <code>CallerMemberName</code>, <code>CallerLineNumber</code>, Stark provides a new compile time attribute <code>CallerArgumentExpression</code> that can extract a string representation of another argument for a method:</p>
<pre><code class="language-stark">// Declare the argument conditionAsText as a string representation of the argument condition
public static func assert(condition: bool, @CallerArgumentExpression(nameof(condition)) conditionAsText: ?string =   null )
{
    // ...
}

// implicitly conditionAsText = &quot;this_is_an_expression &amp;&amp; another_expression&quot;
assert(this_is_an_expression &amp;&amp; another_expression)
</code></pre>
</li>
<li><p>No <code>#ifdef</code> but config instead, similar to <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">Rust <code>[cfg]</code> attribute <code>!cfg</code></a>. In Stark, I would like all the code variations shipped in the library that can be platform dependent or context dependent (tests, benchmarks) to be compiled into the same library.</p>
<pre><code class="language-stark">// Only valid when the &quot;tests&quot; config is passed to the native compiler
@Config(&quot;tests&quot;)
public module all_tests {
    @Test
    public static func my_test() { ... }
}
</code></pre>
</li>
</ul>
<p>But several areas have also not been yet prototyped during this first year:</p>
<ul>
<li>The introduction of <strong>isolated/readability/immutability</strong> concepts and <strong>compile time const data</strong>.</li>
<li><strong>Discriminated unions</strong> (struct and managed, also for <code>?T</code> aka <code>Option&lt;T&gt;</code>) and associated pattern matching</li>
<li>Syntax for <strong>lifetime</strong> for heap allocation (e.g <code>new @PerRequest MyObject()</code> or `new MyObject() in @PerRequest).</li>
<li><strong>Extensions</strong> to add interfaces/methods/properties to an existing class/struct (e.g <code>public extension MyListExtension&lt;T&gt; with List&lt;T&gt; { ... }</code>)</li>
<li><strong>Lightweight function pointers</strong>: Unlike delegates in .NET, a function pointer in Stark would be struct, either static (one function pointer) or closure (one object reference + function pointer). The declaration would follow the declaration of a regular function
<ul>
<li><code>var action: static func(arg: int)</code> is a static function pointer taking an <code>int</code> argument.</li>
<li><code>var closure: func() -&gt; int</code> is a closure function taking no arguments but returning an <code>int</code>.</li>
</ul>
</li>
<li><strong>Lightweight async/await</strong></li>
<li><strong>Yield method iterators</strong> as value types.</li>
<li>Stark driver using simple TOML config to build a library.</li>
</ul>
<h2 id="departure-from-ecma-335">Departure from ECMA-335</h2>
<p>A change like &quot;remove boxing of value type&quot; required a departure from <a href="https://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335</a> as a struct is identified at the IL level when it inherits <code>System.ValueType</code> which is a reference type. The following changes were applied to the standard:</p>
<p>In <strong>II.23.1.15 Flags for types [TypeAttributes]</strong> in the table, at the section <em>Class semantics attributes</em>:</p>
<p>| Flag |  Value | Description |
|-|-|-|
|<code>ClassSemanticsMask</code> | <code>0x00000060</code> (changed) | Use this mask to retrieve class semantics information.
|<code>Class</code> | <code>0x00000000</code> | Type is a class
|<code>Interface</code> | <code>0x00000020</code> | Type is an interface
|<code>Struct</code> | <code>0x00000040</code> (new) | Type is a struct
</p>
<p>It's not the sole change that I had to make. For example:</p>
<ul>
<li>I have also added an <code>Alignment</code> field to <code>ClassLayout</code> in order to specify custom alignment of types (e.g SIMD vector types can require 16 bytes or more)</li>
<li>And modified a couple of flags to (e.g <code>Intrinsics</code> attribute would translate to a flag on <code>[MethodImplAttributes]</code>)</li>
</ul>
<p>I'm trying to keep these changes documented in <a href="https://github.com/stark-lang/stark/blob/master/doc/changes-to-ecma-335.md">changes-to-ecma-335.md</a>.</p>
<p>More changes will have to come for other language features:</p>
<ul>
<li><code>requires</code> contract on methods</li>
<li>Checked exceptions</li>
<li>Immutability/Readable/Isolated concepts</li>
</ul>
<h2 id="fork-of-dnspy">Fork of dnSpy</h2>
<p>In order to check if the compiler was generating valid IL, I wanted to verify this with a tool like ILSpy or dnSpy. Because I had to make changes to ECMA-335/IL Format, I had also to make similar changes to an IL inspector.</p>
<p>I have been maintaining a <a href="https://github.com/stark-lang/stark-dnSpy">fork of dnSpy</a> for Stark:</p>
<img src="/images/stark-dnSpy.png" class="mx-auto" style="display: block"/>
<p>I made the choice of dnSpy mostly because it was possible to inspect raw metadata as well.</p>
<h2 id="fork-of-system.reflection.metadata">Fork of System.Reflection.Metadata</h2>
<p>Another consequence of the change to ECMA-335 is that I had to fork <code>System.Reflection.Metadata</code> which has been renamed to <code>StarkPlatform.Reflection.Metadata</code>.</p>
<p>This library is used by the Stark front-end compiler (e.g Roslyn for C#) to read and write assemblies but also by the native code compiler.</p>
<p>A few changes were made to the original library, like the support for UTF8 string storage and to allow to retrieve a UTF8 without having to allocate a manage object.</p>
<h2 id="ide-integration">IDE Integration</h2>
<p>I thought that I could re-use the integration of Roslyn with Visual Studio to provide an IDE integration but I couldn't get it working correctly. Roslyn is not a regular VS extension but is shipped within VS, and while I have done a few VS extensions in the past, it was way beyond my time and knowledge to be able to make it working.</p>
<p>So instead, I started to look at Visual Studio Code for at least a basic syntax highlighting experience and it turns out that VS Code is very easy to work with for that.</p>
<img src="/images/stark-vscode.png" class="mx-auto" style="display: block"/>
<p>I developed a VS Code package with syntax highlighting for Stark by defining a simple TextMate definition file <a href="https://github.com/stark-lang/stark/blob/master/src/editors/vscode/stark/syntaxes/stark.YAML-tmLanguage">stark.YAML-tmLanguage</a>. Because the syntax is in flux and it is very laborious to define the parsing through regex, I wrote syntax highlighting only for keywords (while for a language like C# they are defining the parsing of almost the entire grammar!).</p>
<p>I have also prototyped using <a href="https://code.visualstudio.com/api/language-extensions/language-server-extension-guide">Language Server Protocol</a> just to see how complicated it would be to integrate with the more advanced user experience and it turns out that it is relatively easy to get notification on every single document change (see for example <a href="https://github.com/stark-lang/stark/blob/master/src/compiler/StarkCompilerServer/TextDocumentHandler.cs">TextDocumentHandler</a>)</p>
<p>Compiling the core library is done for now on the command line with a simple <a href="https://github.com/stark-lang/stark/blob/cd7edc76200142a25636d6c04b53308ad40aaafc/src/runtime/core/build.cmd">build.cmd</a> but you can run also this command directly from VS Code and it will display clickable error messages.</p>
<p>So the current experience is very limited and rough, but it is enough to enjoy prototyping with it.</p>
<p>Not sure if I will be able to work on that any time soon, but enthusiastic contributors could help me developing that part! More on how to contribute in a following blog post.</p>
<h2 id="next-steps">Next Steps</h2>
<p>This first year prototype helped to validate that it was possible to fork Roslyn to build an entire new language and start to build a new core library with it. While it is going to require <em>lots of work</em>  to get it working entirely and correctly, it is very encouraging and promising!</p>
<p>The most challenging part of that work was to make changes to Roslyn, a huge and large codebase, without being able to get PR reviews from more knowledgeable folks of this codebase. I had sometimes to revert some changes realizing that it would not work. I know also that I will have some difficult changes to bring in the future and I fear them in advance.</p>
<p>Because I had to work on the native compiler part, I had also to stop working on the frontend for several months and getting back into the details after such a long period was quite difficult.</p>
<p>But this work on the frontend compiler was fundamental to allow the following work on the native compiler and it will be part of the next blog post of this blog post series!</p>
<p>Stay tuned and Happy coding!</p>

    </div>
  </article>

<div id="gh-comments" data-ghcommentid=9>
  <h2>Comments</h2>
  <div id="gh-comments-list" ></div>
  <a href="javascript:void(0)" id="gh-load-comments" class="btn" style="display:none">Load more comments</a>
</div>
</div>
<div class="col-sm-3">
  <nav class="js-toc toc sticky-top"></nav>
</div>
    </div>
  </div>
	<footer class="blog-footer">
        <p>Copyright &copy; 2009 - 2020, Alexandre Mutel - Blog content licensed under the Creative Commons <a href="http://creativecommons.org/licenses/by/2.5/">CC BY 2.5</a> | Site powered by <a href="https://github.com/lunet-io/lunet">lunet</a></p>
	</footer>  </body>
</html>