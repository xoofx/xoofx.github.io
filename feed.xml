<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xoofx</title>
    <link>https://xoofx.com/</link>
    <description>xoofx website</description>
    <generator>lunet 0.4.1.0</generator>
    <managingEditor>Alexandre Mutel</managingEditor>
    <copyright>Alexandre Mutel</copyright>
    <pubDate>Sun, 13 Dec 2020 13:27:10 +0000</pubDate>
    <lastBuildDate>Sun, 13 Dec 2020 13:27:10 +0000</lastBuildDate>
    <item>
      <title>Stark - Native Compiler - Prototype 2019</title>
      <link>https://xoofx.com/blog/2020/03/21/stark-native-compiler</link>
      <pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2020/03/21/stark-native-compiler</guid>
      <description>This is the second part of the blog post series about The Odyssey of Stark and Melody and more specifically, about the development of a prototype of the native compiler for the Stark language developed during last year. Overview As we saw previously about the front-end compiler, Stark is a language meant to generate native executable code at build time (AOT compiler). From a set of Stark sklib pre-compiled libraries,...</description>
      <category>Stark</category>
      <category>Melody</category>
      <category>OS</category>
      <category>Compiler</category>
      <category>LLVM</category>
      <category>C#</category>
      <category>.NET</category>
    </item>
    <item>
      <title>Stark - Language And Frontend Compiler - Prototype 2019</title>
      <link>https://xoofx.com/blog/2020/03/06/stark-language-frontend-compiler</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2020/03/06/stark-language-frontend-compiler</guid>
      <description>This is the first part of the blog post series about The Odyssey of Stark and Melody and more specifically, about the development of the syntax of the Stark language and its front-end compiler, based on a fork of the C# Roslyn compiler, during its first year prototype last year. Overview The role of a compiler is to transform a higher level representation of some code to a lower level...</description>
      <category>Stark</category>
      <category>Melody</category>
      <category>OS</category>
      <category>Compiler</category>
      <category>LLVM</category>
      <category>C#</category>
      <category>.NET</category>
    </item>
    <item>
      <title>The Odyssey of Stark and Melody</title>
      <link>https://xoofx.com/blog/2020/03/05/stark-melody-dotnet-sel4</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2020/03/05/stark-melody-dotnet-sel4</guid>
      <description> What would it take these days to build a prototype of a new language and operating system built on top of it, just for fun? This idea started to emerge during the 2018 winter holidays: Woot! I just hacked the &quot;Building an Operating System for the Raspberry Pi&quot; https://t.co/tSvS8Bz0ft by writing the kernel in C# and using the AOT Compiler with a slightly modified version of CoreRT to compile...</description>
      <category>Stark</category>
      <category>Melody</category>
      <category>OS</category>
      <category>Compiler</category>
      <category>LLVM</category>
      <category>C#</category>
      <category>.NET</category>
    </item>
    <item>
      <title>Behind the burst compiler</title>
      <link>https://xoofx.com/blog/2019/03/28/behind-the-burst-compiler</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2019/03/28/behind-the-burst-compiler</guid>
      <description>Last year I made a presentation to Unite LA, the dotnetos conference in Warsaw and to the dotnext conference in Moscow of the burst compiler that we have been working on for the past two years at Unity In a nutshell: The burst compiler is a technology aimed at unlocking performance for a subset of C# code beyond what C++ has been usually able to do, by translating .NET IL...</description>
      <category>burst</category>
      <category>Compiler</category>
      <category>C#</category>
      <category>.NET</category>
    </item>
    <item>
      <title>Generate automatically async/await code from sync code with Roslyn</title>
      <link>https://xoofx.com/blog/2018/12/26/generate-async-from-sync-code-with-roslyn</link>
      <pubDate>Wed, 26 Dec 2018 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2018/12/26/generate-async-from-sync-code-with-roslyn</guid>
      <description>This is a quick post to give you some feedback about an experiment I just made with the Scriban Text Templating Library to add support for async/await automatically from the existing synchronous code, all of this done by using Roslyn. If you have an existing code base that works beautifully in a synchronous manner, but you would like also to provide a path for async/await patterns, you don&#39;t want to...</description>
      <category>C#</category>
      <category>.NET</category>
      <category>Roslyn</category>
    </item>
    <item>
      <title>Writing a Managed JIT in C# with CoreCLR</title>
      <link>https://xoofx.com/blog/2018/04/12/writing-managed-jit-in-csharp-with-coreclr</link>
      <pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2018/04/12/writing-managed-jit-in-csharp-with-coreclr</guid>
      <description>As you may know, in .NET CoreCLR (and Mono), the JIT has been entirely written in C/C++. That&#39;s sometimes even a joke used by C++ developers to remind the enthusiastic C# developer crowd that their ecosystem is being actually ran by C++. And that&#39;s the story of any new language (including C), a simple chicken-egg story, that requires to use an existing, more primitive, language and compiler (and at the...</description>
      <category>C#</category>
      <category>.NET</category>
      <category>CoreCLR</category>
    </item>
    <item>
      <title>Porting the Unity Engine to .NET CoreCLR</title>
      <link>https://xoofx.com/blog/2018/04/06/porting-unity-to-coreclr</link>
      <pubDate>Fri, 06 Apr 2018 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2018/04/06/porting-unity-to-coreclr</guid>
      <description>NOTE: This work was a prototype as we don&#39;t have yet an official roadmap and timetable in mind to bring this to Unity, more on that later this year hopefully ;) This blog post is also my own opinionated vision on the subject, but Unity may have different plans and constraints across the teams involved on this. So it may not be the direction Unity will take in the end!...</description>
      <category>C#</category>
      <category>.NET</category>
      <category>CoreCLR</category>
      <category>Unity</category>
    </item>
    <item>
      <title>Productivity with ReSharper</title>
      <link>https://xoofx.com/blog/2018/03/09/productivity-with-resharper</link>
      <pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2018/03/09/productivity-with-resharper</guid>
      <description>I have been using ReSharper for around 10 years now and it has been my number one productivity tool when developing in C#. When Visual Studio 2015 switched to Roslyn I was very annoyed by the massive slow down occurring when using ReSharper and Roslyn together on large solutions. Things have been improving, but still using ReSharper feels more and more heavy with Roslyn and I&#39;m sometimes annoyed by the...</description>
      <category>Visual Studio</category>
      <category>Visual Studio 2015</category>
      <category>Roslyn</category>
    </item>
    <item>
      <title>Implementing a Text Templating Language and Engine for .NET</title>
      <link>https://xoofx.com/blog/2017/11/13/implementing-a-text-templating-language-and-engine-for-dotnet</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2017/11/13/implementing-a-text-templating-language-and-engine-for-dotnet</guid>
      <description> Last year, before developing markdig, I spent a few weeks developing a brand new text templating language and engine called scriban. Though, while I have received a few enthusiastic feedback on this project, I haven&#39;t taken the time to promote, polish and finish it to the level that I originally expected to push... Until the past weeks where I have finally put the last efforts to bring hopefully a...</description>
      <category>C#</category>
      <category>.Net</category>
    </item>
    <item>
      <title>Stark - Language Design Part 2 - Packages and Modules</title>
      <link>https://xoofx.com/blog/2017/02/14/stark-language-design-part-2-packages-and_modules</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      <author>Alexandre Mutel</author>
      <guid isPermaLink="true">https://xoofx.com/blog/2017/02/14/stark-language-design-part-2-packages-and_modules</guid>
      <description>May be surprisingly, my first post about language design for Stark (beyond tokens for the grammar part) is not going to walk through the type system, statements or expressions... But instead focus on how to organize the code of a project/library, how to distribute it (though will not much give details about this) and how to consume it from another project (or from the same project). But obviously, the way...</description>
      <category>Stark</category>
      <category>C#</category>
      <category>Rust</category>
    </item>
  </channel>
</rss>